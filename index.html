<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Life Career</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Life Career">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Life Career">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Life Career">
  
    <link rel="alternate" href="/atom.xml" title="Life Career" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Life Career</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-翻译：成为多语种的程序员（Being a Polyglot Programmer）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/06/翻译：成为多语种的程序员（Being a Polyglot Programmer）/" class="article-date">
  <time datetime="2019-03-06T07:05:00.000Z" itemprop="datePublished">2019-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/06/翻译：成为多语种的程序员（Being a Polyglot Programmer）/">翻译：成为多语种的程序员（Being a Polyglot Programmer）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="翻译：成为多语种的程序员（Being-a-Polyglot-Programmer）"><a href="#翻译：成为多语种的程序员（Being-a-Polyglot-Programmer）" class="headerlink" title="翻译：成为多语种的程序员（Being a Polyglot Programmer）"></a>翻译：成为多语种的程序员（Being a Polyglot Programmer）</h2><h3 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h3><ul>
<li><a href="https://www.infoq.com/news/2017/05/being-polyglot-programmer" target="_blank" rel="external">原文地址</a></li>
<li><a href="https://polyconf.com/" target="_blank" rel="external">polyconf网站地址</a>，可以通过各个演讲者（speaker）的<a href="https://eventil.com" target="_blank" rel="external">eventil</a>找到他们在polyconf上的演讲视频，了解更多多语言（polyglot）方面的内容</li>
<li>本文是Qcon对PolyConf创建者Zaiste的采访，主要阐述Zaiste对polyglot的基本目标、方法的介绍，帮助读者理解polyglot</li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><ul>
<li>年轻的IT开发者会学习多种不同的编程语言，这其中甚至包括Fortran这样的上古时代的语言。但当他们步入职场之后，使用的语言往往会走向单一（公司内部统一）</li>
<li>Zaiste在语言的使用上另辟蹊径，他每年都会学习新的语言，并在实际项目中使用这些语言。他非常重视多语言的实践，为此创建了大型的会议组织<a href="https://polyconf.com/" target="_blank" rel="external">Polyglotism in IT：PolyConf</a>来探讨这个议题。PolyConf将在2017年的6月7日-6月9日在巴黎La Géode举行。InfoQ将全程会议的新闻、Q&amp;A、文章等内容</li>
<li>在InfoQ FR对Zaiste的采访中，他谈到了自己探索使用多种语言编程的实践经历、动机、不同语言基础范式上的差异，以及今年PolyConf的一些公开的内容</li>
<li><font color="blue">InfoQ FR：</font>Zaiste，麻烦您做一下自我介绍</li>
<li><font color="red">Zaiste: </font>大家好，我是Zaiste，我在巴黎经营一家软件公司，业余爱好会组织国际性的技术事件，其中最大的就是PolyConf。我从12年前开始从事编程工作，当时在银行系统使用java相关的技术，包括Struts 1和Spring等。2005年我开始使用Ruby &amp; Rails，两年后组织了Ruby &amp; Python方面的会议（RuPy）。目前我主要享受JavaScript编程，尤其是最新版本。另外，我对Clojure、OCaml和Reason社区也都保持关注，期望能找到时间进行更深入的了解</li>
<li><font color="blue">InfoQ FR：</font>为什么你认为PolyGlotism这么重要，你为此专门创建了PolyConf会议</li>
<li><font color="red">Zaiste: </font>多语言编程不是单纯为了使用一次语言，或在单一项目中使用某一语言。核心的目标是为了在软件开发艺术中获取通用性的认知和技能，鼓励程序员跨越语言边界，从深度和广度两方面更加深入的理解编程。在这基础上进一步提升和拓展编程技能。在这一点上，米开朗基罗和达芬奇是我们的榜样，他们不仅是发明家、导师、建筑师，同样也是画家和雕塑家。拥有匠心的程序员，不应该局限于一两门编程语言的使用。</li>
<li>就业市场上，雇主一般都要求在专一领域有多年实践经验积累。熟练掌握Angular通常意味着没有React相关技能，作为js对同一个问题的两种解决方案，程序员一般都是选择其中一个方案深入使用和实践。从维护成本上考虑，企业一般都会使用统一的技术栈，从多种语言/框架中选择其中一个，这就决定了企业会选择技术栈不那么广，但是在企业所在的技术栈上有足够的深度和经验的程序员。</li>
<li><font color="blue">InfoQ FR：</font>你在日产工作中怎么时间多语言编程？</li>
<li><font color="red">Zaiste: </font>PolyConf帮助我从不同的视角全面深入的理解我所使用的语言和工具。我在这个过程中，见证了一些上古时期的技术或者不流行的技术变得流行，也见证了已经被遗忘的技术又重新被采用。这种“多语言编程实践”让我对编程有了一个全面的视角。通过对不同技术的使用和对比，我可以更快的了解新技术的侧重点和应用场景</li>
<li><font color="blue">InfoQ FR：</font>最近在探索哪些新兴的语言？</li>
<li><font color="red">Zaiste: </font>我特别喜欢Rust和OCaml，这两个语言都带来了独特的特性。Rust是一个非常非常快的系统编程语言(System Programming Language, 区别于Application Programming Language)。OCaml是一个多范式（multi-paradigm）语言，支持函数式编程、命令式编程和面向对象编程（OOP）</li>
<li><font color="blue">InfoQ FR：</font>业界有一些其他的多语言编程相关的会议（conference），你创立PolyConf的目的是什么？</li>
<li><font color="red">Zaiste: </font>是的，我乐见业界出现更多关于多语言编程的会议。大家的目标是统一的，都是要促进编程语言和相关社区的交流。PolyConf希望能成为其中的一支重要力量</li>
<li><font color="blue">InfoQ FR：</font>如果我参加PolyConf能看到什么内容</li>
<li><font color="red">Zaiste: </font>今年虚拟机是会议的焦点，Chris Seaton会介绍Oracle基于Ruby的高性能动态编译器和解释器Graal。Maxime Chevalier-Boisvert将会介绍她们正在建设中的动态语言平台。Jack Moffitt将介绍Servo，这是用Rust写的浏览器引擎原型。Dalcol将会讨论Lua和LuaJIT。这些是我们会议的主要内容。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/06/翻译：成为多语种的程序员（Being a Polyglot Programmer）/" data-id="cjsx38q49000090fy5envak53" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Polyglot/">Polyglot</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java classloader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/10/java classloader/" class="article-date">
  <time datetime="2019-02-10T12:28:00.000Z" itemprop="datePublished">2019-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/10/java classloader/">java classloader详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>classloader是用来加载 Class 的。它负责<font color="red">将Class 的字节码形式转换成内存形式的 Class 对象</font>。字节码可以来自于磁盘文件 <em>.class，也可以是 jar 包里的 </em>.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。</li>
<li>JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是<font color="red">延迟加载</font>。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。</li>
<li><font color="red">虚拟机使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。</font></li>
<li>类名和classloader都相同，jvm才会视为同一个类（同一个Class对象）</li>
<li>classLoader功能：<img src="../images/classloader.png" alt="image"></li>
<li>核心方法<pre><code><br>package java.lang;<br>public abstract class ClassLoader {<br>  public Class loadClass(String name);<br>  protected Class defineClass(byte[] b);<br>  public URL getResource(String name);<br>  public Enumeration getResources(String name);<br>  public ClassLoader getParent();<br>}<br></code></pre></li>
</ul>
<h2 id="classloader设计思路"><a href="#classloader设计思路" class="headerlink" title="classloader设计思路"></a>classloader设计思路</h2><h3 id="jvm-classloader"><a href="#jvm-classloader" class="headerlink" title="jvm classloader"></a>jvm classloader</h3><ul>
<li>Bootstrap Classloader<ul>
<li>Bootstrap Classloader本身没有parent加载器，但是可以用作其它Classloader实例的parent classloader</li>
<li>加载jvm运行时核心类库JAVA_HOME/lib/rt.jar中的java.util,java.nio,java.lang等</li>
</ul>
</li>
<li>ExtClassLoader<ul>
<li>负责加载jvm扩展类，位于 JAVA_HOME/lib/ext/*.jar中的类</li>
<li>parent是Bootstrap Classloader</li>
</ul>
</li>
<li>AppClassLoader<ul>
<li>直接面向用户端的classloader，加载Classpath环境变量里定义的路径中的jar包和目录。我们自己的代码及二方/三方jar包通常都是这个类加载器加载</li>
<li>parent是ExtClassLoader</li>
</ul>
</li>
<li>类图结构 <img src="../images/jvm_classloader.jpg" alt="image"></li>
</ul>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><ul>
<li>什么是双亲委派<ul>
<li>当一个ClassLoader实例需要加载某个类时，<ul>
<li><ol>
<li>首先由最顶层的类加载器Bootstrap ClassLoader试图加载</li>
</ol>
</li>
<li><ol>
<li>如果没加载到，则把任务转交给Extension ClassLoader试图加载</li>
</ol>
</li>
<li><ol>
<li>如果也没加载到，则转交给App ClassLoader 进行加载</li>
</ol>
</li>
<li><ol>
<li>如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类</li>
</ol>
</li>
<li><ol>
<li>如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常</li>
</ol>
</li>
</ul>
</li>
<li>委派关系示意图<img src="../images/classloader_parent_delegate.png" alt="image"></li>
</ul>
</li>
<li>为什么使用双亲委派<ul>
<li>避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次</li>
<li>安全性考虑，避免核心类库功能被随意替代</li>
</ul>
</li>
</ul>
<h3 id="Thread-contextClassLoader"><a href="#Thread-contextClassLoader" class="headerlink" title="Thread.contextClassLoader"></a>Thread.contextClassLoader</h3><ul>
<li>SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由<strong>启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)</strong>来加载的。</li>
<li>Bootstrap Classloader是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。</li>
<li>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</li>
<li>两种使用场景<ul>
<li><ol>
<li>SPI。当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。</li>
</ol>
</li>
<li><ol>
<li>当使用本类托管类加载，然而加载本类的ClassLoader未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="classloader应用"><a href="#classloader应用" class="headerlink" title="classloader应用"></a>classloader应用</h2><h3 id="自定义从远程文件创建class对象"><a href="#自定义从远程文件创建class对象" class="headerlink" title="自定义从远程文件创建class对象"></a>自定义从远程文件创建class对象</h3><ul>
<li><pre><code>
public class NetworkClassLoader extends ClassLoader {  
  private String rootUrl;  
  @Override 
  protected Class<?> findClass(String name) throws ClassNotFoundException {  
      Class clazz = null;//this.findLoadedClass(name); // 父类已加载     
      //if (clazz == null) {  //检查该类是否已被加载过  
          byte[] classData = getClassData(name);  //根据类的二进制名称,获得该class文件的字节码数组  
          if (classData == null) {  
              throw new ClassNotFoundException();  
          }  
          clazz = defineClass(name, classData, 0, classData.length);  //将class的字节码数组转换成Class类的实例  
      //}   
      return clazz;  
  }  
  private byte[] getClassData(String name) {  
      InputStream is = null;  
      String path = classNameToPath(name);  
      URL url = new URL(path);  
      byte[] buff = new byte[1024*4];  
      int len = -1;  
      is = url.openStream();  
      ByteArrayOutputStream baos = new ByteArrayOutputStream();  
      while((len = is.read(buff)) != -1) {  
          baos.write(buff,0,len);  
      }  
      return baos.toByteArray();  
  }   
  private String classNameToPath(String name) {  
      return rootUrl + "/" + name.replace(".", "/") + ".class";  
  }  
}
</code></pre>

</li>
</ul>
<h3 id="dubbo-中的classloader"><a href="#dubbo-中的classloader" class="headerlink" title="dubbo 中的classloader"></a>dubbo 中的classloader</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.jianshu.com/p/c3a49a4b2efb" target="_blank" rel="external">Java ClassLoader 透析</a></li>
<li><a href="https://www.jianshu.com/p/6e5c2b463b2a" target="_blank" rel="external">深入分析Java ClassLoader原理</a></li>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="external">真正理解线程上下文类加载器（多案例分析）</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/10/java classloader/" data-id="cjs1hnfbt0000sxfylkrp1d0t" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/classloader/">classloader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/06/redis实践/" class="article-date">
  <time datetime="2019-02-05T16:28:00.000Z" itemprop="datePublished">2019-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/06/redis实践/">redis实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="redis实践case"><a href="#redis实践case" class="headerlink" title="redis实践case"></a>redis实践case</h2><h3 id="阻塞式队列"><a href="#阻塞式队列" class="headerlink" title="阻塞式队列"></a>阻塞式队列</h3><ul>
<li>命令<ul>
<li>lpop/rpop</li>
<li>弹出列表key(可以指定多个)的头元素</li>
<li>lpop [key…]</li>
</ul>
</li>
<li><p>blpop/brpop</p>
<ul>
<li>弹出列表key(可以指定多个)的头元素，若队列为空则阻塞一定时间或到队列有元素位置。多个阻塞的请求使用FIFO的方式响应。timeout=0则一直阻塞</li>
<li>blpop [key…] timeout</li>
<li>实现原理：redis服务器是文件事件和时间事件的双重事件处理器，所以虽然单线程处理文件事件，但是队列为空需要阻塞时，key会被push到名为blocking_keys的dict结构中，当有push操作时，会查找blocking_keys有无对应的key，若有则返回到第一个被阻塞的client</li>
</ul>
</li>
<li><p>rpush/lpush</p>
<ul>
<li>将一个或多个值插入队列尾端</li>
</ul>
</li>
<li><p>rpoplpush </p>
<ul>
<li>将队列任务直接转移到processing队列，等到process完成再移除processing队列，从而实现at least once保证</li>
<li>rpoplpush taskqueue processingTaskqueue</li>
</ul>
</li>
<li><p>目标：</p>
<ul>
<li>可靠性，是否需要支持分布式事务</li>
<li>支持什么样的一致性保证（at least once/at most once）</li>
<li>吞吐量保证</li>
<li>参考<a href="http://blog.bronto.com/engineering/reliable-queueing-in-redis-part-1/" target="_blank" rel="external">http://blog.bronto.com/engineering/reliable-queueing-in-redis-part-1/</a></li>
</ul>
</li>
<li>我们实际实现时，没有用redis的bpop命令，而是在客户端进行status缓存，每隔一段时间去刷新status，减小阻塞在redis端的线程。使用bpop应该问题也不大</li>
</ul>
<h3 id="分布式锁，实现不同时间单位的流量控制"><a href="#分布式锁，实现不同时间单位的流量控制" class="headerlink" title="分布式锁，实现不同时间单位的流量控制"></a>分布式锁，实现不同时间单位的流量控制</h3><ul>
<li>命令<ul>
<li>incr/incrby</li>
<li>decr/decrby</li>
<li>原子的对一个key进行加减操作</li>
<li>incr/decr key</li>
<li>incrby/decrby key amount</li>
</ul>
</li>
</ul>
<h2 id="redis实践问题"><a href="#redis实践问题" class="headerlink" title="redis实践问题"></a>redis实践问题</h2><h3 id="缓存倾斜"><a href="#缓存倾斜" class="headerlink" title="缓存倾斜"></a>缓存倾斜</h3><ul>
<li>hot key造成的集群访问量倾斜<ul>
<li>hot key是指一段时间内，某些访问量远远高于其它redis key的key，导致大部分的访问流量都落在hot key所在的slot/redis节点，常见的hot key场景有：</li>
<li><ol>
<li>库存系统/秒杀系统中，最热门的商品信息或库存</li>
</ol>
</li>
<li><ol>
<li>新闻应用之中的热点新闻</li>
</ol>
</li>
</ul>
</li>
<li><p>方案：</p>
<ul>
<li>一、本地缓存，考虑两个问题：<ul>
<li>hot key过多时，本地缓存是否会过大</li>
<li>本地缓存同redis数据的一致性</li>
</ul>
</li>
<li>二、利用分片算法特性，将key进行打散处理<ul>
<li>在hot key上增加后缀/前缀，一般数量是集群节点数量N <em> 指定倍数M个tmp key，这N</em> M个tmp key分摊到不同的实例上，将访问量均摊到所有实例。一份数据变成了N*M+1份，多分数据之间的一致性保证就是一件高成本的事情，因此写多读少的场景可能不适合</li>
<li>N*M个tmp key备份数据要随机使用不同的缓存时间（随机），防止tmp key同时失效造成缓存雪崩，这是一种通过坡度过期的方式避免雪崩的思路</li>
<li>tmp key的前缀后缀策略，注意twemproxy的计算分片时，越靠前的字符权重越大，越靠后的字符权重越小，因此当key特别长时，加后缀有可能起不到分散到不同节点的作用</li>
</ul>
</li>
</ul>
</li>
<li><p>big key造成集群的数据量倾斜</p>
<ul>
<li>big key是指数据大小远大于其它key，导致分片之后，big key所在（量大）的节点内存使用量远大于其它实例，造成内存不足，拖累集群。常见的big key场景由：</li>
<li><ol>
<li>论坛中大型持久盖楼活动</li>
</ol>
</li>
<li><ol>
<li>聊天系统中热门聊天室的消息列表</li>
</ol>
</li>
</ul>
</li>
<li><p>方案：对数据进行拆分（数据必须是可拆分的列表、set等）</p>
<ul>
<li>一、hset，将key的内容打散到不同的实例中</li>
<li>二、list，将list拆分成子list</li>
</ul>
</li>
<li><p>既是big key也是hot key</p>
<ul>
<li><ol>
<li>考虑是否适合redis存储</li>
</ol>
</li>
<li><ol>
<li>可否迁出集群，采用master+replication/读写分离的方式来存储</li>
</ol>
</li>
</ul>
</li>
<li><p>如何发现hot key和big key</p>
<ul>
<li>一、基于业务预判</li>
<li>二、监控<ul>
<li><ol>
<li>在应用程序端进行收集</li>
</ol>
</li>
<li><ol>
<li>在proxy层进行redis请求的收集（推荐）</li>
</ol>
</li>
<li><ol>
<li>在redis实例上使用monitor统计热点key（高并发时产生的overhead过高）</li>
</ol>
</li>
<li><ol>
<li>对redis端口进行数据抓包</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自动处理</p>
<ul>
<li><ol>
<li>发现big key和hot key，进行报警</li>
</ol>
</li>
<li><ol>
<li>自动处理big key和hot key，例如建立一套中间层，升级为big key或hot key的key访问，转为hot key/big key方式的访问</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><ul>
<li>第一种：大量缓存几种在某一个时间段失效</li>
<li>解决方案：<ul>
<li><ol>
<li>缓存访问流控(只允许一个线程穿透到数据库，通过JVM同步或者分布式同步实现)，</li>
</ol>
</li>
<li><ol>
<li>缓存坡度过期策略（不同的key使用不同的缓存过期时间，例如在基础有效时长上加一个随机数，这个随机数越大，以为着坡度越大，缓冲器越长，压力就会越小）</li>
</ol>
</li>
<li><ol>
<li>在缓存更新时间与缓存过期时间之间增加容忍期，相当于缓存永远不会失效，那当然不会有雪崩问题</li>
</ol>
</li>
</ul>
</li>
<li>第二种：或者缓存服务器宕机/hot key失效，导致并发访问在短时间内几种到数据库后端系统<ul>
<li><ol>
<li>通过HA架构提高缓存服务的可靠性</li>
</ol>
</li>
<li><ol>
<li>数据库保护性访问流控（保护了数据库和依赖数据库的其它业务，但是当前业务的可用性收到影响），</li>
</ol>
</li>
<li><ol>
<li>当遇到缓存服务器宕机/hot key失效这些场景，只能进行保护性降级，熔断-&gt;限流-&gt;隔离</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><ul>
<li>并发很高的场景下，某个key没有在缓存中，短时间内对该key的大量并发访问就会全部穿透到数据库中，或者大量非法/无效的key被同时访问，对后端造成很大的压力，被称为缓存穿透</li>
<li><p>解决方案</p>
<ul>
<li><ol>
<li>布隆过滤器，空key缓存/key existing判断（bitmap存储），或者直接怼查询过的空key加入到缓存</li>
</ol>
</li>
<li><ol>
<li>对key做按规则的过滤</li>
</ol>
</li>
</ul>
</li>
<li><p>缓存与db数据的一致性保证</p>
<ul>
<li><ol>
<li>数据库更新时同步更新，监听binlog异步更新</li>
</ol>
</li>
<li><ol>
<li>以库存为例，直接使用缓存做更新，redis可以通过incr和decr操作判断库存是否足够，并直接完成库存扣减。无论是db扣减还是缓存扣减，都要使用增量方式完成。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://segmentfault.com/a/1190000017387491" target="_blank" rel="external">link1</a></li>
<li><a href="https://zhangxh20.github.io/2017/09/04/redis/cacheCollapse/" target="_blank" rel="external">link2</a></li>
<li><a href="https://yq.aliyun.com/articles/540337" target="_blank" rel="external">link3</a></li>
<li><a href="https://www.jishuwen.com/d/2Hnm" target="_blank" rel="external">link4</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/06/redis实践/" data-id="cjrrzufsh00009vfycyo6gobn" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SOA方法论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/27/SOA方法论/" class="article-date">
  <time datetime="2019-01-27T14:00:00.000Z" itemprop="datePublished">2019-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/27/SOA方法论/">SOA架构总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SOA方法论"><a href="#SOA方法论" class="headerlink" title="SOA方法论"></a>SOA方法论</h2><ul>
<li>SOA原则：自治和管制</li>
<li>服务间调用使用消息替代RPC调用，实现依赖剥离</li>
<li>服务都是无连接的</li>
<li>SOA目标和优势：<ul>
<li>松耦合。服务自治，各系统之间划定服务边界，服务调用通过接口发布。调用方无需关心服务实现细节，利于团队工作划分和业务发展</li>
<li>位置透明。消费者无需关心服务位置</li>
<li>可在异构平台之间使用</li>
<li>便于测试和并行开发</li>
</ul>
</li>
</ul>
<h2 id="RPC核心组件"><a href="#RPC核心组件" class="headerlink" title="RPC核心组件"></a>RPC核心组件</h2><h3 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h3><ul>
<li>provider需要以某种形式提供服务调用的相关信息，一般用IDL文件来暴露其服务信息。dubbo使用xml文件注册其提供的服务内容，并通过zookeeper来实现服务的负载均衡和容灾</li>
<li>同一语言平台的RPC通过共享接口定义来实现</li>
</ul>
<h3 id="远程代理对象"><a href="#远程代理对象" class="headerlink" title="远程代理对象"></a>远程代理对象</h3><ul>
<li>jdk动态代理，突出可读性。实现代理对象一样的接口，并实现代理功能。如统一封装发送远程调用请求</li>
<li>java动态代理简介<pre><code><br>public interface InvocationHandler{<br>  public Object invoke(Object proxy, Method method, Object[] args);<br>}<br>public class DynamicProxy implements InvocationHandler{<br>  private Object proxy;<br>  public Object invoke(Object proxy, Method method, Object[] args){<pre><code>preProcess();
Object rs = method.invoke(proxy, args);
proProcess();
return rs;
</code></pre>  }<br>}<br></code></pre></li>
<li>字节码生成，突出性能</li>
</ul>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul>
<li>协议：TCP、HTTP<ul>
<li>传输层协议TCP性能更好</li>
<li>WebService 就是基于HTTP的RPC，具有良好的跨平台性，性能不如TCP</li>
</ul>
</li>
<li>IO方式，使用NIO</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>java<ul>
<li>Java序列化是对对象的结构和内容的完全描述，所以数据会比较大，但是安全可靠。</li>
<li>性能差，必须要手动管理serializationUID</li>
</ul>
</li>
<li>protobuf<ul>
<li>只针对数据进行序列化，数据小，性能高</li>
<li>通过额外的protobuf配置文件，在序列化和反序列化两方约定数据的格式</li>
<li>protobuf在数据表示方面也进行了一些技巧来减小数据的大小<ul>
<li>varint 越小的数字占用的存储越小</li>
<li>sint 由于有符号负数在计算机中需要用一个很大的数值来表示，这样用上述varint来表示就一定需要5个byte（比使用正常的32bit整型还大）        - optional字段不序列化</li>
<li>数据类型也用一个WiredType来映射</li>
</ul>
</li>
<li>封包/解包速度<ul>
<li>XML需要进行复杂的文法词法分析，而protobuf只要简单的将二进制序列按照指定的格式读取到C++对应的结构类型中    </li>
</ul>
</li>
</ul>
</li>
<li>Hessian<ul>
<li>hessian相当于一个java和protobuf平衡的方案，省去protobuf的配置文件，在程序逻辑中进行一些数据大小的优化</li>
<li>着重数据的序列化，简单类型信息会直接附带；复杂类型序列化成Map，包含基本类型描述和数据内容。</li>
<li>在序列化过程中，如果一个对象之前出现过，hessian会直接插入一个R index这样的块来表示一个引用位置，从而省去再次序列化和反序列化的时间。</li>
</ul>
</li>
<li>一些最佳实践原则<ul>
<li>子类的field不应该跟父类冲突（相同）</li>
<li>不论是父类/子类，java序列化必须显示声明serializationUID否则可能会随着代码和环境的变化，产生版本冲到导致的反序列化错误</li>
<li>引用其它对象时，也要遵从响应的原则</li>
</ul>
</li>
</ul>
<h3 id="负载均衡（dubbo）"><a href="#负载均衡（dubbo）" class="headerlink" title="负载均衡（dubbo）"></a>负载均衡（dubbo）</h3><ul>
<li>服务列表。使用zk进行管理，通过zk保证分布式数据的一致性，当服务地址发生变更时，zk要主动通知各client，保证列表的实时性和有效性</li>
<li>支持手动下线</li>
<li>选择算法。部分算法支持手动权重调节<ul>
<li>random</li>
<li>round robin</li>
<li>consistent hash，相同参数的请求总是被发送到同一个provider</li>
<li>least active loadbalance，为provider维护一个未完成的调用数量统计，这样可以使慢的服务得到少的请求</li>
</ul>
</li>
<li>注意路由/负载均衡/failover的区别<ul>
<li>路由，是根据路由配置选出调用子集（如指定调用最近的机房的provider列表）</li>
<li>负载均衡，在路由选出来的provider列表中按上述的算法选出一台服务器进行调用</li>
<li>failover，负载均衡到某台机器，但是这台机器失败时，需要换一个机器</li>
</ul>
</li>
<li>dubbo支持客户使用SPI机制对负载均衡进行定制扩展。</li>
</ul>
<h2 id="常见RPC组件"><a href="#常见RPC组件" class="headerlink" title="常见RPC组件"></a>常见RPC组件</h2><h3 id="google-GRPC"><a href="#google-GRPC" class="headerlink" title="google GRPC"></a>google GRPC</h3><h3 id="阿里-dubbo-核心代码"><a href="#阿里-dubbo-核心代码" class="headerlink" title="阿里 dubbo 核心代码"></a>阿里 dubbo 核心代码</h3><ul>
<li>BeanDefinition。从xml配置文件加载bean定义，用BeanDefinition对象表示，spring先转化得到BeanDefinition列表，再用BeanDefinition对象初始化所有的Bean</li>
<li>DubboBeanDefinitionParser/BeanDefinitionParser(spring)。DubboBeanDefinitionParser将dubbo配置文件转化为Dubbo相关的BeanDefinition定义</li>
<li>ReferenceBean/ReferenceConfig。DubboBeanDefinitionParser将bean定义用ReferenceBean和ReferenceConfig来表示，包含了服务接口名、服务器地址url、方法、客户端类型、Invoker等远程调用信息。</li>
<li>Invoker。封装了远程调用的逻辑，管理具体的Client来向远程服务器发送请求。Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li>
<li>Invocation。Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数，同步异步，isoneway等。</li>
<li>ProxyFactory/JdkProxyFactory/JavaassistProxyFactory。代理对象生成逻辑，JdkProxyFactory使用java动态代理，JavaassistProxyFactory使用字节码生成技术。</li>
<li>ExchangeClient/Client/EndPoint。执行具体的transport层功能。</li>
<li>LoadBalance。实现上述具体的负载均衡策略。</li>
</ul>
<h3 id="苹果thrift"><a href="#苹果thrift" class="headerlink" title="苹果thrift"></a>苹果thrift</h3><h2 id="其它服务组织"><a href="#其它服务组织" class="headerlink" title="其它服务组织"></a>其它服务组织</h2><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><ul>
<li>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。<ul>
<li>客户端和服务器间的请求无状态</li>
<li>分层系统，这表示组件无法了解它与之交互的中间层以外的组件。通过将系统知识限制在单个层，可以限制整个系统的复杂性，促进了底层的独立性。</li>
<li>资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。</li>
</ul>
</li>
</ul>
<h3 id="REST架构和RPC架构比较"><a href="#REST架构和RPC架构比较" class="headerlink" title="REST架构和RPC架构比较"></a>REST架构和RPC架构比较</h3><ul>
<li>在 RPC 样式的架构中，关注点在于方法，而在 REST 样式的架构中，关注点在于资源 —— 将使用标准方法检索并操作信息片段（使用表示的形式）</li>
<li>RESTful的关键是定义可表示流程元素/资源的对象。在REST中，每一个对象都是通过URL来表示的，对象用户负责将状态信息打包进每一条消息内，以便对象的处理总是无状态的。</li>
<li>RESTful的第二大问题是组合管理及流程绑定。企业对正规的（基于SOAP）SOA最大的反对声之一便是，这种等级的发现和绑定灵活性不足以适应复杂性。    </li>
</ul>
<h3 id="microservice"><a href="#microservice" class="headerlink" title="microservice"></a>microservice</h3><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="external">google protocol buffer使用和原理</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1_%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B%E6%9D%A5%E4%BA%86?lang=zh" target="_blank" rel="external">IBM “容器技术和微服务”系列课程 </a> </li>
<li><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-loadbalance.html" target="_blank" rel="external">dubbo官方负载均衡文档</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/27/SOA方法论/" data-id="cjrrz76p4000171fyyd4xaor5" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SOA/">SOA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/27/笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》/" class="article-date">
  <time datetime="2019-01-27T13:25:00.000Z" itemprop="datePublished">2019-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/27/笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》/">笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><ul>
<li>CAP定理：一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）这三个基本需求，最多只能同时满足其中两个</li>
<li>一致性：数据在多个版本之间能否保持一致。注意有强一致性和最终一致性之分</li>
<li>可用性：分布式系统要在有限时间内返回有效结果</li>
<li>分区容错性：遇到部分网络分区故障时，仍然能对外提供满足一致性和可用性的服务</li>
<li>因为网络是必然可能出现问题，因此分区容错性是分布式系统必须要面对和重点解决的问题，因此架构设计师往往把精力花在C和A之间寻求平衡</li>
</ul>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul>
<li>BASE是CAP对一致性和可用性权衡的结果（基于CAP理论中提到的P必须要保证的前提）</li>
<li>其核心思想是，即使不能做到强一致性，但每个应用都可以根据自己的业务特点，采用适当的方式达到最终一致性</li>
<li>BA：Basically Available，S：Soft state，E：Eventually consistent</li>
<li>基本可用：①损失响应速度②容许部分功能被降级（主动/被动）</li>
<li>弱状态：允许不同节点数据副本之间存在同步延迟（短时间内读到的数据可能不一致）</li>
<li>最终一致性：经过一段时间可以达成一致，而不需要实时保证系统数据一致性（强一致性）</li>
<li>最终一致性的五种体现形式：<ul>
<li>因果一致性：A进程更新后，B进程要更新必须基于A进程更新后的最新之，不能发生丢失更新的情况</li>
<li>读己之所写：单个进程，读到的数据一定不能比自己上次写入的旧</li>
<li>会话一致性：单个会话中实现的读己之所写</li>
<li>单调读一致性：一个进程从系统中读到的数据必须是单调变新的</li>
<li>单调写一致性：一个系统要能够保证同一个进程的写操作顺序的执行</li>
</ul>
</li>
</ul>
<h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><h3 id="一致性问题描述"><a href="#一致性问题描述" class="headerlink" title="一致性问题描述"></a>一致性问题描述</h3><ul>
<li>分布式系统中，每个机器节点可以明确知道自己的事务状态，但无法直接获知其它分布式节点的操作结果。</li>
<li>当一个事务操作需要跨越多个分布式事务节点的时候，为了保持事务的ACID特性，需要引入一个叫做Coordinator协调者的组件来统一调度所有分布式节点的执行逻辑。被调度的分布式节点被称为参与者Participant。</li>
<li>协调者负责调度参与者的行为，并最终决定参与者是否要把事务真正提交。基于这个衍生出了2PC和3PC两种协议</li>
</ul>
<h3 id="分布式系统一致性的核心需求："><a href="#分布式系统一致性的核心需求：" class="headerlink" title="分布式系统一致性的核心需求："></a>分布式系统一致性的核心需求：</h3><ul>
<li>确保分区容错性（P），在一致性（C）和可用性（A）之间做平衡。两种方案：①在保证可用性时，使用最终一致性（E）②在保证强一致性时，牺牲部分可用性（BA）</li>
<li>使用Qorum（半数以上）机制保证系统不会产生split brain</li>
</ul>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><ul>
<li>提交事务请求阶段/投票阶段<ul>
<li>事务询问。协调者向所有的参与者发送事务内容</li>
<li>执行事务。各参与者执行事务操作，并记录undo、redo日志</li>
<li>参与者向协调者反馈事务执行结果</li>
</ul>
</li>
<li>执行事务提交<ul>
<li>协调者发出commit请求</li>
<li>参与者收到commit请求后，正式commit事务</li>
<li>参与者发送ACK</li>
<li>协调者收到所有的ACK，完成事务commit</li>
</ul>
</li>
<li><p>回滚事务</p>
<ul>
<li>发送rollback请求</li>
<li>用Undo日志回滚事务</li>
<li>发送rollback ACK</li>
<li>协调者收到所有的ACK，完成事务中断</li>
</ul>
</li>
<li><p>优点：原理简单，实现方便</p>
</li>
<li>缺点：<ul>
<li>同步阻塞，二阶段执行过程中所有参与事务的逻辑都处于阻塞状态，参与者无法进行其它操作，极大的限制分布式系统的性能</li>
<li>协调者单点问题</li>
<li>数据不一致。某个参与者的网络在投票阶段过后中断，无法收到协调者发送的执行事务提交的请求，就会导致数据不一致的情况</li>
<li>没有容错机制，任何节点失败都会导致失败</li>
</ul>
</li>
</ul>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><ul>
<li>2PC的改进版，将事务提交阶段一分为2，行程canCommit、preCommit、doCommit三个阶段</li>
<li>canCommit<ul>
<li>事务询问。协调者向所有参与者发送事务内容</li>
<li>参与者响应执行结果</li>
</ul>
</li>
<li>preCommit-commit<ul>
<li>发送预提交请求。</li>
<li>事务预提交。执行事务，并记录Redo、undo日志</li>
<li>参与者反馈执行响应</li>
</ul>
</li>
<li>preCommit-rollback<ul>
<li>发送中断请求</li>
<li>中断事务</li>
</ul>
</li>
<li>doCommit-commit<ul>
<li>发送提交请求</li>
<li>执行提交</li>
<li>反馈执行结果</li>
<li>完成提交事务</li>
</ul>
</li>
<li>doCommit-rollback<ul>
<li>发送中断请求</li>
<li>事务回滚</li>
<li>反馈回滚结果</li>
<li>完成中断事务</li>
</ul>
</li>
<li>优点：<ul>
<li>降低了参与者的阻塞范围</li>
<li>能够在出现单点故障后达成一致（超时事务会提交）</li>
</ul>
</li>
<li>缺点：网络故障默认提交事务，会导致数据不一致</li>
</ul>
<h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><ul>
<li>概述：<ul>
<li>基于消息传递且具有高度容错性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法</li>
<li>Paxos目的是，如何在一个易发生机器宕机或网络异常的分布式环境中，快速且正确的在集群内部对某个数据的值达成一致</li>
</ul>
</li>
<li>优点<ul>
<li>引入了过半原则</li>
<li>支持节点角色转换</li>
<li>解决无限期等待问题</li>
</ul>
</li>
</ul>
<h3 id="Paxos的工程实践——Chubby"><a href="#Paxos的工程实践——Chubby" class="headerlink" title="Paxos的工程实践——Chubby"></a>Paxos的工程实践——Chubby</h3><ul>
<li><p>一些实现特性：</p>
<ul>
<li>设计成了类似标准文件系统的结构，并支持相同的访问方式（ZK用类似的实现）</li>
<li>客户端缓存+服务端通知机制，减少服务端的压力</li>
<li>缓存租期+加会话延迟机制，给客户端闪断恢复的机会</li>
</ul>
</li>
<li><p>Chubby对Paxos算法的实现：</p>
<ul>
<li>Paxos算法在Chubby中的作用在于保证集群内各个副本节点的日志能够保持一致性</li>
<li>保证集群副本日志一致性</li>
<li>保证master故障切换时副本之间的一致性</li>
</ul>
</li>
<li>三层结构：<ul>
<li>底层容错日志（顺序日志）</li>
<li>K-V容错数据库</li>
<li>上层分布式锁服务和小文件存储服务</li>
</ul>
</li>
</ul>
<h3 id="ZK与Paxos"><a href="#ZK与Paxos" class="headerlink" title="ZK与Paxos"></a>ZK与Paxos</h3><ul>
<li>Zookeeper是一个开源的分布式协调服务，有Yahoo创建，是Google Chubby的开源实现。Zookeeper的目的是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</li>
<li><p>Zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现以下功能：</p>
<ul>
<li>数据发布/订阅</li>
<li>负载均衡</li>
<li>命名服务</li>
<li>分布式协调/通知</li>
<li>集群管理</li>
<li>Master选举</li>
<li>分布式锁和分布式队列</li>
</ul>
</li>
<li><p>ZK保证的分布式一致性特性：</p>
<ul>
<li>顺序一致性。同一个客户端发起的事务请求，最终将严格地按照其发起的顺序被应用到Zookeeper中</li>
<li>原子性。要么所有机器都成功应用了某一个事务，要么都没有应用</li>
<li>单一视图。无论客户端连接的是哪个服务器，看到的服务端数据模型都是一致的</li>
<li>可靠性/Duration。事务完成后不丢失</li>
<li>实时性。ZK保证的是BASE中的Basically Available</li>
</ul>
</li>
<li><p>ZK设计目标</p>
<ul>
<li>简单的数据模型：树形结构的名字空间，由一系列的ZNode数据节点组成，也是用的类似文件系统的目录结构，为了高效实用，全部由内存提供服务</li>
<li>可以构建集群。</li>
<li>顺序访问。实用全局唯一的事务编号，来反应事务操作的先后顺序。</li>
<li>高性能。主要面向读多写少的场景，性能非常高。</li>
</ul>
</li>
</ul>
<h3 id="ZK基本概念"><a href="#ZK基本概念" class="headerlink" title="ZK基本概念"></a>ZK基本概念</h3><ul>
<li>集群角色。<ul>
<li>Leader。提供读写服务，协调Qorum写机制</li>
<li>Follower提供读服务，参与Leader选举，参与Qorum写</li>
<li>Observer，仅提供读服务</li>
</ul>
</li>
<li>会话。客户端与服务端的TCP长连接</li>
<li>数据节点ZNode。树形结构，类似/foo/path1</li>
<li>版本。每个ZNode都有一个Stat数据结构，记录了version（当前ZNode版本）、cversion（当前ZNode子节点版本）、aversion（当前ZNode的ACL版本）</li>
<li>Watcher。客户端通知机制</li>
<li>Access Control Lists。数据权限控制，类似文件系统的权限</li>
</ul>
<h3 id="ZAB协议（Zookeeper-Atomic-Broadcast）"><a href="#ZAB协议（Zookeeper-Atomic-Broadcast）" class="headerlink" title="ZAB协议（Zookeeper Atomic Broadcast）"></a>ZAB协议（Zookeeper Atomic Broadcast）</h3><ul>
<li>核心：定义了对于那些会改变ZooKeeper服务器数据状态的事务请求处理方式。</li>
<li>所有事务请求必须由一个全局唯一的服务器来协调处理，即leader服务器</li>
<li>Leader服务器将一个事务请求转换为一个事务Proposal，并分发给所有Follower</li>
<li>Follower对proposal进行响应，若超过半数Follower，就进行事务commit</li>
</ul>
<h3 id="两种基本模式："><a href="#两种基本模式：" class="headerlink" title="两种基本模式："></a>两种基本模式：</h3><ul>
<li>崩溃恢复</li>
<li>消息广播</li>
</ul>
<h3 id="基本特性："><a href="#基本特性：" class="headerlink" title="基本特性："></a>基本特性：</h3><ul>
<li>恢复模式会丢弃只在Leader服务器上被提出的事务（因为新的Leader不知道这个事务，且客户端可能已针对没有这个事务的数据状态做出了一系列的改变）</li>
<li>被选举的Leader必须是拥有当前最大事务ID的服务器，省去新leader从其它服务器同步数据的过程</li>
</ul>
<h3 id="ZAB与Paxos区别："><a href="#ZAB与Paxos区别：" class="headerlink" title="ZAB与Paxos区别："></a>ZAB与Paxos区别：</h3><ul>
<li>ZAB协议用于构建一个高可用的分布式数据主备系统</li>
<li>Paxos用于构建一个分布式的一致性状态机系统</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/27/笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》/" data-id="cjrrz76oz000071fyxrvklduz" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PAXOS/">PAXOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-笔记——《java并发编程的艺术》" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/笔记——《java并发编程的艺术》/" class="article-date">
  <time datetime="2019-01-26T14:50:00.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/笔记——《java并发编程的艺术》/">笔记——《java并发编程的艺术》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="（一）并发编程的挑战"><a href="#（一）并发编程的挑战" class="headerlink" title="（一）并发编程的挑战"></a>（一）并发编程的挑战</h2><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><ul>
<li>由于CPU的时间分片逻辑，以及当前线程在某些条件（执行完成/等待资源/主动让出）下让出CPU权时，就是所谓的任务切换</li>
<li>上下文切换：CPU切换任务时，需要保存当前任务的状态，加载下一个任务的状态的过程</li>
<li>要尽可能减少上下文切换：<ul>
<li>无锁并发编程</li>
<li>CAS算法</li>
<li>避免不必要的多线程</li>
<li>协程</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>必要条件：<ul>
<li>互斥</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
</li>
<li>避免死锁的常见办法（破坏上述必要条件中的一个）：<ul>
<li>避免一个线程内同时获取多个锁，避免一个锁占有多个资源</li>
<li>使用定时锁</li>
<li>顺序加锁</li>
</ul>
</li>
<li>资源限制<ul>
<li>要根据资源数量调整并发度，例如网速上线20M，每个线程可以占用10M时，就不必使用多于2个线程</li>
</ul>
</li>
</ul>
<h2 id="（二）并发机制的底层实现原理"><a href="#（二）并发机制的底层实现原理" class="headerlink" title="（二）并发机制的底层实现原理"></a>（二）并发机制的底层实现原理</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul>
<li>定义：Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的值是相同的，更简单一点理解就是volatile修饰的变量值发生变化时对于另外的线程是可见的</li>
<li>优势：volatile不会引起线程上下文切换和调度，所以比synchronized使用和执行成本更低</li>
<li>volatile的实现原理是，在执行完成后，触发2件事情：<ul>
<li>将当前处理器缓存行的数据写回到内存系统</li>
<li>通过缓存一致性协议，使其它处理器里缓存行对应的内存失效（被修改）</li>
</ul>
</li>
<li>什么情况下使用volatile：<ul>
<li>主要原则：写入变量不依赖变量值</li>
<li>场景1：状态标记（指示发生了一个重要的一次性事件）</li>
<li>独立观察（获取最后一个访问者）</li>
</ul>
</li>
<li>一些底层问题（硬件级别）：<ul>
<li>为了提高处理速度，处理器不直接和内存进行通信，而是先将内存数据读到处理器内部缓存，但是操作完成后缓存同步到内存的时间是不确定的。</li>
<li>缓存一致性协议要锁定整个行，因此有些时候，这个协议会导致不必要的内存锁。例如JDK7中的LinkedTransferQueue，就将队头队尾进行了扩充（64字节），防止队头队尾被加载到同一个处理器缓存行中导致的队头队尾同时被锁的问题（出队时不能入队或入队时不能出队，实际上它们是完全可以安全的并发运行的）</li>
</ul>
</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>synchronized锁的三种表现形式：<ul>
<li>非static方法：锁是当前实例对象</li>
<li>static方法：锁是当前类的Class对象</li>
<li>方法块：锁是synchronized声明括号中的对象</li>
</ul>
</li>
<li>java对象头里的Mark Word默认存储了对象的锁信息</li>
<li>java中几种锁类型。为了减少获得锁和释放锁带来的性能消耗，1.6以后引入了3个级别的锁状态，偏向锁、轻量锁、重量锁，锁的成功率也由低到高，锁的使用成本由低到高，锁可以升级，但是不能降级。<font color="red">不同级别的锁本质上是JVM在对锁的竞争程度有一定判断的基础上，力图通过乐观锁、自旋锁来提升锁的同步性能的策略。</font><ul>
<li>偏向锁。当某一线程获取锁并执行完成后，在锁对象中保留线程ID，下次再获取锁时检查当前线程ID是否等于锁对象中的线程ID，若是则不用再重新加锁/解锁，直接进入同步块；否则，撤销原有的线程ID，重新获取偏向锁，执行完成后记录新的线程ID</li>
<li>轻量级锁。在当前栈帧中创建锁记录，将锁对象头中的MarkWord复制到这个锁记录中，再用CAS将对象头中MarkWord的轻量锁指针指导当前线程的锁记录，如果失败，会适用自旋来获取锁；执行完成后，重置线程锁记录和锁对象MarkWord的数据，完成解锁</li>
<li>重量级锁。其它线程在遇到无法获取锁的时候会直接BLOCK。</li>
</ul>
</li>
</ul>
<h3 id="原子操作的实现"><a href="#原子操作的实现" class="headerlink" title="原子操作的实现"></a>原子操作的实现</h3><ul>
<li>总线锁，锁总线，所有的处理器都会被阻塞，不能操作其它内存地址</li>
<li>缓存锁（锁某一行缓存），只会锁当前缓存行</li>
<li>java原子操作的另一种方式：循环CAS<ul>
<li>AtomicInteger、AtomicLong、AtomicReference</li>
<li>问题：ABA、竞争激烈时循环时间长开销大</li>
</ul>
</li>
</ul>
<h2 id="（三）Java内存模型"><a href="#（三）Java内存模型" class="headerlink" title="（三）Java内存模型"></a>（三）Java内存模型</h2><h3 id="Java内存模型基础："><a href="#Java内存模型基础：" class="headerlink" title="Java内存模型基础："></a>Java内存模型基础：</h3><ul>
<li>并发编程的关键问题：线程通信。Java通过共享内存实现线程通信</li>
<li>内存模型抽象结构：每个线程在其线程对象内保存共享变量的副本，当某个线程修改共享变量时，其它线程如何获取这个修改，就是Java线程通信的关键</li>
<li>指令重排序：<ul>
<li>编译器优化排序</li>
<li>CPU优化：指令级并行技术（Instruction-Level Parallelism）将多条指令重叠执行</li>
<li>CPU优化：使用缓存和读写缓冲区，加载和存储操作看上去可能是乱序执行</li>
<li>java内存模块JMM通过在生成指令序列时，插入内存屏障指令，禁止某些CPU重排序</li>
</ul>
</li>
<li>happens-before。如果一个操作执行结果要对另一个操作可见，那么两个操作之间就是happens-before关系</li>
<li>指令重排序：<ul>
<li>as-if-serial：不管怎么重排序，程序的执行结果不能被改变</li>
<li>在不改变程序执行结果的前提下，尽可能提高并行度</li>
</ul>
</li>
</ul>
<h2 id="（四）Java并发编程基础"><a href="#（四）Java并发编程基础" class="headerlink" title="（四）Java并发编程基础"></a>（四）Java并发编程基础</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>什么是线程：操作系统调度的最小单元，也叫轻量级进程，一个进程可以创建多个线程，这些线程都拥有各自的计数器、堆栈、局部变量等属性，能够访问共享的变量内存</li>
<li>为什么要多线程：<ul>
<li>多处理器</li>
<li>业务异步解耦</li>
<li>异步I/O，某个线程等待IO时，可以把CPU使用权交给其他线程</li>
</ul>
</li>
<li>线程优先级：处理器会参考优先级对线程进行调度，但是不保证优先级高的比优先级低的先执行。</li>
<li>线程状态：<img src="../images/java-thread-state.jpg" alt="image"></li>
</ul>
<h3 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h3><ul>
<li>thread.start()</li>
<li>thread.interrupt()。线程中断可以理解为线程的一个标志位属性，表示一个运行中的线程是否被其它线程进行了中断操作</li>
<li>thread.cancel()。终止线程</li>
</ul>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ul>
<li>volatile&amp;synchronized，不同级别的同步</li>
<li>wait/notify机制，解决轮询太多占CPU和轮询太少线程执行不及时的问题。wait/notify依赖同步机制</li>
<li>wait/notify经典范式<ul>
<li>wait方：获取锁 -&gt; 条件不满足，调用wait -&gt; 条件满足执行对应逻辑</li>
<li>notify方：获取锁-&gt; 改变条件 -&gt; notify/notifyAll</li>
</ul>
</li>
<li>join()。用于处理线程顺序依赖关系，前文我们说过优先级不能用来保证顺序，join可以</li>
</ul>
<h2 id="（五）Java中的锁"><a href="#（五）Java中的锁" class="headerlink" title="（五）Java中的锁"></a>（五）Java中的锁</h2><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><ul>
<li>使用Lock接口比使用synchronized<ul>
<li>需要显式声明和释放锁</li>
<li>锁的可操作性（声明/释放）、可中断锁、超时锁、读写锁等synchronized所没有的功能</li>
<li>非阻塞的获取锁（不阻塞，而是直接返回获取成功还是失败）</li>
</ul>
</li>
<li>组件<ul>
<li>lock()</li>
<li>lockInterruptibly()</li>
<li>tryLock()</li>
<li>unlock()</li>
<li>Condition</li>
</ul>
</li>
</ul>
<h3 id="队列同步器AQS"><a href="#队列同步器AQS" class="headerlink" title="队列同步器AQS"></a>队列同步器AQS</h3><ul>
<li>队列同步器是实现锁的关键，在锁的实现中聚合同步器，实现锁的语义</li>
<li>锁是面向使用者的，定义了使用者与锁交互的接口，隐藏了实现细节</li>
<li>同步器面向的是锁的实现，简化了锁的实现方式，屏蔽了同步状态管理，线程排队，等待与唤醒等底层操作</li>
<li>管理同步状态方法：<ul>
<li>getState()</li>
<li>setState(int newState)</li>
<li>compareAndSetState(int expect, int update)</li>
</ul>
</li>
<li>用于子类进行扩展的方法<ul>
<li>isHeldExclusively()</li>
<li>tryAcquire()</li>
<li>tryRelease(int releases)</li>
</ul>
</li>
<li>实现。<ul>
<li>阻塞队列：阻塞线程创建Node加入队列，原理参考阻塞队列一章，各个节点自旋的获取同步队列（也有升级进入到park状态的逻辑）</li>
<li>独占式：state==0时设置state完成占用</li>
<li>共享式：state&gt;0是设置state完成占用（要根据state的更新定义调整，比如原始值是2，占用时-1，就可以限定在state&gt;0时完成占用）</li>
</ul>
</li>
</ul>
<h3 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h3><ul>
<li>线程不会被自己阻塞。当前线程可以重复修改state（条件与其它线程不一致）</li>
</ul>
<h3 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h3><ul>
<li>readLock()、writeLock()</li>
<li>一个变量维护多种状态，使用按位切割使用的方法</li>
</ul>
<h3 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h3><h3 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h3><ul>
<li>await()、signal()</li>
<li>condition用一个同步队列来公平的调度正在等待信号的线程</li>
</ul>
<h2 id="（六）Java并发容器和框架"><a href="#（六）Java并发容器和框架" class="headerlink" title="（六）Java并发容器和框架"></a>（六）Java并发容器和框架</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul>
<li>HashMap线程不安全，并发写会引起死锁；HashTable用synchronized来保证线程安全，效率很低</li>
<li>get方法通过定义成volatile，来保证可见性</li>
<li>put方法通过锁分段（Segment）来实现写并发（不同segment上的数据可以并发写）</li>
</ul>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><ul>
<li>通过CAS实现无锁并发队列</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li>阻塞队列是指队列在队列满时阻塞写队列线程；队列为空时阻塞读队列线程的队列，常用于producer/consumer问题</li>
<li>阻塞队列的几个要求：①满队列/空队列时的producer/consumer线程阻塞②公平性（按照阻塞先后顺序访问队列）</li>
<li>ArrayBlockingQueue。用数组实现的阻塞队列，出队时需要进行数组元素复制迁移</li>
<li>LinkedBlockingQueue。用链表实现的阻塞队列</li>
<li>PriorityBlockingQueue。支持优先级的队列，高优先级的先出队，相同优先级没有顺序保证</li>
<li>DelayQueue。支持延时获取元素的阻塞队列</li>
<li>SynchronousQueue。不存储元素，每一个put操作必须等待一个take操作，否则不能继续添加元素</li>
<li>LinkedTransferQueue。在consumer阻塞时，将生产者的输出直接transfer给consumer</li>
<li>LinkedBlockingDeque。双向阻塞队列</li>
<li>实现原理：一个Lock（ReentrantLock）&amp;两个Condition。UNsafe.park()是线程进入阻塞状态</li>
</ul>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h3><ul>
<li>Fork/Join是把一个大问题分解为若干个小问题，并最终汇总小问题的执行结果得到最终结果</li>
<li>工作窃取算法。切分任务并发时，某个线程完成了自己的任务，去其它线程的队列中窃取任务来执行</li>
<li>设计。实现ForkJoinTask接口，使用ForkJoinPool来执行</li>
</ul>
<h2 id="（七）Java中的12个原子操作类"><a href="#（七）Java中的12个原子操作类" class="headerlink" title="（七）Java中的12个原子操作类"></a>（七）Java中的12个原子操作类</h2><h3 id="原子基本类型（原子更新某个值）"><a href="#原子基本类型（原子更新某个值）" class="headerlink" title="原子基本类型（原子更新某个值）"></a>原子基本类型（原子更新某个值）</h3><ul>
<li>AtmoicInteger</li>
<li>AtomicLong</li>
<li>AtomicBoolean<h3 id="原子数组（原子更新数组中的某个值）"><a href="#原子数组（原子更新数组中的某个值）" class="headerlink" title="原子数组（原子更新数组中的某个值）"></a>原子数组（原子更新数组中的某个值）</h3></li>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3></li>
<li>AtomicReference</li>
<li>AtomicReferenceFieldUpdater</li>
<li>AtomicMarkableReference<br>原子更新字段类</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
<li>AtomicStampedReference</li>
</ul>
<h2 id="（八）Java中的并发工具类"><a href="#（八）Java中的并发工具类" class="headerlink" title="（八）Java中的并发工具类"></a>（八）Java中的并发工具类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ul>
<li>场景：当某个线程需要等待N个子线程完成之后再执行后续逻辑时。</li>
<li>可以用join()来实现，join用于让当前线程等待join线程执行结束，原理是不停检查join线程是否存活。join线程终止后，线程的notifyAll会被调用</li>
<li>CountDownLatch的N可以在任意场景减一，因此可以实现等待N个线程，也可以等待1个线程里的N个执行步骤，或者二者的组合。CountDownLatch的N只能通过countDown()方法减1，不能回退</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><ul>
<li>场景与CountDownLatch类似，但是CyclicBarrier在遇到错误时可以重置计数器，重新计算</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>Semaphore用来控制同时访问特定资源的线程数量。</li>
<li>用acquire()获取资源，用release()释放资源。当无法获取到资源时，线程处在wait()状态，当释放资源时，线程会调用notifyAll()</li>
</ul>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><ul>
<li>用于两个线程交换数据</li>
</ul>
<h2 id="（九）Java中的线程池"><a href="#（九）Java中的线程池" class="headerlink" title="（九）Java中的线程池"></a>（九）Java中的线程池</h2><h3 id="为什么要使用线程池："><a href="#为什么要使用线程池：" class="headerlink" title="为什么要使用线程池："></a>为什么要使用线程池：</h3><ul>
<li>降低资源消耗。重复利用已创建的线程，避免创建-销毁过程造成的消耗</li>
<li>提高响应速度。因为不需要创建线程，加快了执行速度</li>
<li>提高线程的可管理性。使用线程池统一分配、调优、监控，合理使用系统资源</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>组件：核心池+非核心池+工作队列</li>
<li>Worker线程循环执行任务，保留线程状态</li>
</ul>
<h3 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h3><ul>
<li>初始化new ThreadPoolExecutor(corePoolSize, maimumPoolSize, keepAliveTime, timeUnit, queue, threadFactory, handler)</li>
<li>执行：threadPool.execute(Runnable), threadPool.submit(Runnable)</li>
<li>关闭：shutdown()或shutdownNow()</li>
<li>优化：CPU密集型线程不能太多，IO密集型可以增加并发度1</li>
</ul>
<h3 id="线程池类型："><a href="#线程池类型：" class="headerlink" title="线程池类型："></a>线程池类型：</h3><ul>
<li>FixedThreadPool</li>
<li>SingleThreadPool</li>
<li>CacheThreadPool</li>
</ul>
<h2 id="（十）Executor框架"><a href="#（十）Executor框架" class="headerlink" title="（十）Executor框架"></a>（十）Executor框架</h2><h3 id="成员："><a href="#成员：" class="headerlink" title="成员："></a>成员：</h3><ul>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
<li>Future。实现Future接口可以返回一个执行结果</li>
<li>Runnable/Callable Runnable不能返回执行结果，Callable可以返回执行结果</li>
</ul>
<h3 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h3><ul>
<li>通过DelayQueue(通过时间实现的PriorityQueue)来对任务排序，并按顺序取到时的任务执行</li>
</ul>
<h3 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a>AbstractQueueSynchronizer</h3><ul>
<li>AQS提供通用机制来管理同步状态、阻塞和唤醒线程，以及维护被阻塞的线程队列</li>
<li>AQS应用广泛，基于AQS实现的同步器包括：ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、FutureTask</li>
<li>acquire()用于阻塞线程，知道AQS状态允许线程继续执行</li>
<li>release()用于改变AQS状态，改变后的状态能够允许一个或多个阻塞线程被解除阻塞</li>
</ul>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><ul>
<li>使用一个volatile的state来管理run()和get()之间的同步关系</li>
<li>FutureTask run()执行之后，在设置执行结果set(V)时，设置state为完成</li>
<li>FutureTask get()执行时检查state是否为完成，若不是就阻塞</li>
</ul>
<h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><ul>
<li>必须先获取锁，才能通过wait/notify，如果锁是排他的，这会不会没有意义？wait操作会释放其对应的锁！！</li>
<li>producer/consumer中的生产和消费者怎样实现公平策略（先被阻塞的线程在notify之后先执行）？增加同步队列，从队列中完成调度，而不依赖CPU的调度。例如AQS中当前线程执行后，通过队列链表唤醒后续节点unparkSuccessor(h)</li>
<li>Java为什么效率比其它语言高？垃圾回收、简单易用的并发组件（thanks to Doug Lea）</li>
<li>一些并发最佳实践原则：<ul>
<li>给线程起可追踪的名字，包括单个线程，线程池</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/26/笔记——《java并发编程的艺术》/" data-id="cjrdn99z40000k8fyw69hmmcx" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DevOps核心目标与方法体系" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/26/DevOps核心目标与方法体系/" class="article-date">
  <time datetime="2019-01-26T14:30:07.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/26/DevOps核心目标与方法体系/">DevOps核心目标与方法体系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>DevOps核心目标：<ul>
<li>DevOps是一种方法论，包含一系列的基本原则和实践，而docker、jenkins、chef、puppet等一系列工具链只是为这个方法论。这套方法论可以理解为敏捷开发向运维团队的延伸拓展</li>
<li>保持系统运作流程不中断</li>
<li>随时提升和优化工作流程</li>
</ul>
</li>
<li>DevOps基本原则<ul>
<li>infrastructure as code</li>
<li>continuous delivery</li>
<li>culture of collaboration</li>
</ul>
</li>
<li>实践方法：<ul>
<li>流程化将复杂的问题常规化</li>
<li>自动化减小人工成本及错误率<br>工具链（从编码到生产环境维护）</li>
<li>编码：IDE/VCS（idea/git）</li>
<li>构建：持续集成工具（jenkins、crp、阿里云效）</li>
<li>测试：jenkins+junit/testng</li>
<li>打包：maven nexus</li>
<li>发布：jenkins</li>
<li>配置：IaS工具</li>
<li>监视：应用程序监视及最终用户体验（icinga、elk）</li>
<li>问题排查工具：greys/btrace/housemd、jmap/jstack/jstat、JMX&amp;visualVM</li>
</ul>
</li>
<li>收益：<ul>
<li>可重复性与可靠性</li>
<li>生产力</li>
<li>恢复时间</li>
<li>确保基础架构的同质</li>
<li>维持整齐划一的标准</li>
<li>让开发者自行完成大部分工作</li>
</ul>
</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="jenkins实现持续发布"><a href="#jenkins实现持续发布" class="headerlink" title="jenkins实现持续发布"></a>jenkins实现持续发布</h3><ul>
<li>tomcat发布<ul>
<li>服务上下线</li>
<li>负载均衡上下线</li>
<li>服务检测</li>
</ul>
</li>
<li>前端发布<ul>
<li>资源上线</li>
<li>cdn同步</li>
</ul>
</li>
<li>脚本/配置发布<ul>
<li>git统一管理代码和配置 </li>
<li>启动脚本同步</li>
<li>系统配置/etc/hosts</li>
<li>elk配置 logstash配置，elasticsearch配置 </li>
<li>服务器列表</li>
</ul>
</li>
</ul>
<h3 id="icinga集群实现系统监控报表"><a href="#icinga集群实现系统监控报表" class="headerlink" title="icinga集群实现系统监控报表"></a>icinga集群实现系统监控报表</h3><ul>
<li>redis集群监控<ul>
<li>shell命令自动化生成redis节点监控配置，共计约1000个节点</li>
<li>集群模式，1master，16个worker，防止load过高问题</li>
<li>监控属性配置，服务状态、连接数、内存、碎片率、命中数、CPU使用率</li>
<li>短信报警</li>
</ul>
</li>
<li>ecs基础监控<ul>
<li>磁盘/CPU/内存</li>
<li>ecs自带报警</li>
</ul>
</li>
<li>tomcat服务器监控</li>
<li>监控策略    <ul>
<li>下线配置</li>
<li>报警策略</li>
</ul>
</li>
</ul>
<h3 id="ELK业务监控报表"><a href="#ELK业务监控报表" class="headerlink" title="ELK业务监控报表"></a>ELK业务监控报表</h3><ul>
<li>异常日志监控</li>
<li>抓取监控，时间、状态、各业务线各代理商的时间和状态</li>
<li>数据访问层监控（执行时间，异常）</li>
</ul>
<h3 id="自动化shell脚本"><a href="#自动化shell脚本" class="headerlink" title="自动化shell脚本"></a>自动化shell脚本</h3><ul>
<li>发布脚本appctl.sh appctl1.sh appctl2.sh</li>
<li>ssh-key免登</li>
<li>测试环境相关脚本</li>
<li>icinga集群部署脚本，自动生成监控文件</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.infoq.cn/article/detail-analysis-of-devops" target="_blank" rel="external">detail-analysis-of-devops</a></li>
<li><a href="https://www.cnblogs.com/jetzhang/p/6068773.html" target="_blank" rel="external">什么是DevOps</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/26/DevOps核心目标与方法体系/" data-id="cjrdn99zc0001k8fygdtxwvwl" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/">DevOps</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-笔记：redis设计与实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/笔记：redis设计与实现/" class="article-date">
  <time datetime="2019-01-20T03:00:07.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/笔记：redis设计与实现/">笔记：redis设计与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="redis设计与实现笔记（一）：redis数据结构介绍"><a href="#redis设计与实现笔记（一）：redis数据结构介绍" class="headerlink" title="redis设计与实现笔记（一）：redis数据结构介绍"></a>redis设计与实现笔记（一）：redis数据结构介绍</h2><h3 id="redis用到的几种数据结构："><a href="#redis用到的几种数据结构：" class="headerlink" title="redis用到的几种数据结构："></a>redis用到的几种数据结构：</h3><ul>
<li>简单动态字符串SDS，Simple Dynamic String</li>
<li>链表</li>
<li>字典</li>
<li>跳表</li>
<li>整数集合</li>
<li>压缩列表</li>
<li>对象</li>
</ul>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><ul>
<li>SDS<ul>
<li>SDS的结构。通过一个length属性表示字符串长度，free属性表示剩余可用长度，char[]属性记录字符串值，用以适应redis中使用C字符串产生的不足</li>
</ul>
</li>
<li>链表。linkedlist<ul>
<li>就是一般的链表结构，C语言没有链表数据结构，所以Redis自己进行了实现</li>
<li>Redis链表的一些特征：双向、无环、带表头表尾指针、长度计数器、多态</li>
</ul>
</li>
<li>字典。又称符号表（Symbol Table），关联数组（associative array），或映射（map），用于保存键值对<ul>
<li>类似于java中的HashMap，因为C语言没有这个结构，所以Redis自己进行了实现</li>
<li>Redis的数据库就是通过字典来实现</li>
<li>dict数据结构包含一个长度为2的哈希表dictht数组，一个dictType指针保存不同类型对象的哈希等处理方法，哈希表内部使用链表来处理哈希冲突</li>
<li>当loadfactor过高时（有BGSAVE或BGREWRITEAOF运行时=5，没有时=1），会触发Redis rehash操作，渐进式rehash执行过程中的相关操作都要在dictht[1]上也执行对应的操作（如添加新的键值对时，也要rehash到dictht[1]）</li>
<li>MurmurHash2算法：名字来源于MU（multiply）R（Rotate），很多开源项目都在使用（Redis、Lucene、Memcached等），与其它流行hash算法相比，对于规律性较强的key，MurmurHash随机分布特征表现更良好，key大于10时运行速度更快</li>
</ul>
</li>
<li>跳表。skiplist是一个平均O(LogN)，最坏O(N)查找复杂度的有序数据结构，性能可以媲美平衡树，但是实现比平衡树简单，所以不少程序使用跳表来替代平衡树<ul>
<li>跳表是有序集合的底层实现之一，包含zskiplist和zskiplistNode两个数据结构，zskiplist记录跳表的头尾、长度等基础信息</li>
<li>节点按分值大小有序排列，当分值相同时，按对象自身的大小比较逻辑排列</li>
</ul>
</li>
<li>整数集合intset。当一个集合只包含整数元素且数量不多时，Redis就会使用整数集合作为集合的底层实现<ul>
<li>ordered、distinct方式保存数值</li>
<li>有利于更高效的处理整数类型的小集合，如状态位、标志位、或者我们业务中常用到的代理商列表</li>
<li>主要通过对数字类型进行保守处理（用最小的长度）来节约整数消耗的内存</li>
<li>因为可能涉及O(N)的类型变更和内存再分配，所以不适用大集合</li>
</ul>
</li>
<li>压缩列表ziplist。压缩列表是哈希和列表的底层实现之一，当一个列表只包含少量数据，且只有小整数或短字符串时，Redis就会使用压缩列表来实际存储这些数据，从而节约内存<ul>
<li>encoding属性记录数据的类型及长度</li>
<li>跟java的不同主要在于列表底层类型不固定，可以重新分配数据类型，重新分配内存，Redis中涉及很多类似的设计</li>
<li>previous_entry_length更新可能会导致连锁更新（当列表元素长度变大，例如原始1字节254字节以内，变为500字节，就需要将previous_entry_length扩展），所以也不使用大集合</li>
<li>用连续内存存储，相比hashtable减小了内存碎片；节省了指针占用的内存；</li>
</ul>
</li>
<li>对象。Redis并没有直接使用上述数据结构来实现kv数据库，而是基于这些数据结构创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象、有序集合对象<ul>
<li>使用对象的好处：<ul>
<li>Redis命令执行前，可以根据对象的类型来判断一个对象是否可以执行给定的命令。</li>
<li>针对不同的使用场景，从上述底层数据结构中选择合适的底层实现，从而优化不同场景的性能</li>
</ul>
</li>
<li>Redis实现了基于引用计数的内存回收机制</li>
<li>Redis实现了对象共享机制，通过共享数据来节约内存</li>
<li>Redis对象的定义：type、encoding、ptr(底层数据结构)</li>
</ul>
</li>
</ul>
<h3 id="上层数据结构"><a href="#上层数据结构" class="headerlink" title="上层数据结构"></a>上层数据结构</h3><ul>
<li>String对象的底层实现：<pre><code>- int。保存整数值
- embstr。小于39字节的字符串、long double浮点数
- raw。大于39字节字符串、long double浮点数
</code></pre></li>
<li>列表对象list底层：<ul>
<li>ziplist。字符串长度小于64字节，元素个数小于512个。</li>
<li>linkedlist。</li>
</ul>
</li>
<li>哈希对象底层：<ul>
<li>ziplist。key-value都小于64字节，元素数小于512个。随机访问和写入都是O(N)复杂度</li>
<li>hashtable。内存占用大，O(1)随机访问和写入复杂度</li>
</ul>
</li>
<li>集合对象set底层：<ul>
<li>intset。当所有数据都是整数且数量不多于512时</li>
<li>hashtable。</li>
</ul>
</li>
<li>有序集合对象zset：<ul>
<li>ziplist。元素小于64字节且数量不多于128个</li>
<li>zset。使用一个跳表和一个dict共同实现。跳表用于有序查找，dict保存元素的score用于随机获取分值</li>
</ul>
</li>
</ul>
<h3 id="其它数据特性"><a href="#其它数据特性" class="headerlink" title="其它数据特性"></a>其它数据特性</h3><ul>
<li>命令类型检查。检查对象是否支持当前命令，否则返回错误提示</li>
<li>命令多态。针对不同的底层数据结构，路由到对应的底层API</li>
<li>引用计数支持的内存回收和对象共享（只共享0-9999数字）</li>
<li>空转时长支持内存LRU</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>可以看到Redis实现，做了许多内存友好性的工作，例如自建的字符串结构、intset、ziplist等，有些场景甚至牺牲了部分性能来优化内存，这是Redis的取胜之道</li>
</ul>
<h2 id="redis设计与实现笔记（二）：单机数据库实现"><a href="#redis设计与实现笔记（二）：单机数据库实现" class="headerlink" title="redis设计与实现笔记（二）：单机数据库实现"></a>redis设计与实现笔记（二）：单机数据库实现</h2><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><ul>
<li>服务器状态类redisServer，redisServer包含一个redisDB数组表示数据库，并通过配置指定dbNum个数据库。默认redisClient访问的是db[0]，可以通过select命令指定数据库。</li>
<li>redisDb结构主要属性是一个dict字典结构，这个dict保存了数据库中所有的键值对，这个字典称为键空间（key space）</li>
<li>一般的增删改查操作都是在这个dict进行的，可以理解为java map中的相关的get/set等操作，并针对不同的对象进行了扩展，比如如果map的对象还是一个map，支持hset/hget等。</li>
<li>redisDb还会维护一些常用基本信息，比如keyCount，keyspace_hits，keyspace_misses等</li>
<li>过期时间相关操作：expire/expireAt/setex/ttl等。过期之后相应的key就无法查询到，数据库会通过一定的策略删除过期key</li>
<li>redisDb结构包含一个expires字典，保存了数据库中所有key的过期时间，通过该字典支持上述的过期相关的操作</li>
<li>过期键删除策略<ul>
<li>定时删除。设置过期键的同时，创建一个定时器（Timer），让定时器在键的过期时间来临时，立即对键执行删除操作。内存最友好、CPU最不友好，难以实现。</li>
<li>惰性删除。CPU最友好，内存最不友好，且如果大量键不再被访问或很少被访问，效果会等同于内存溢出，只能手动FLUSHDB</li>
<li>定期删除。定时和惰性的折中方案，定期删除，并设置执行时间和频率减少对CPU影响。Redis通过一个随机策略来执行，而不是遍历</li>
</ul>
</li>
</ul>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><ul>
<li>RDB文件是一个压缩的二进制文件，用于对redis数据库进行持久化，防止数据丢失。RDB文件不同于AOF，它存储的是持久化时数据库的快照，而AOF类似于数据库binlog和事件流</li>
<li>SAVE 阻塞式的持久化，BGSAVE异步非阻塞式生成RDB文件</li>
<li>自动定期保存，可以结合更新操作的频率设置不同的条件，定期自动通过BGSAVE进行持久化保存，比如60s内执行了1000次更新，300秒内执行了100次更新，1000秒内执行了1次更新等。这个操作有ServerCron定期执行，默认100毫秒就会执行一次</li>
<li>RDB文件结构。RDB文件持久化或从RDB加载时的文件格式，涉及一些文件checksum校验，压缩存储等基本思想，不在这里一一罗列，请参考原作了解</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><ul>
<li>AOF（append only file）、RDB和replication对过期键的处理<ul>
<li>生成RDB不会写入过期键</li>
<li>载入RDB取决于启动模式，主服务器模式不载入过期键，从服务器会载入过期键</li>
<li>AOF写入。没有影响，append DEL记录即可</li>
<li>AOF重写。与生成RDB类似，不写入过期键</li>
<li>replication。由主服务器进行删除管理，从服务器存在过期数据被读取到的可能，这种模式可以保证主从服务器数据一致性</li>
</ul>
</li>
<li>AOF持久化可以分为命令追加（append）、文件写入、文件同步（sync）</li>
<li>AOF处于打开时，服务器执行完一个写命令后，会按协议将被执行的命令追加写入到redisServer.aof_buf缓冲区</li>
<li>AOF文件写入和同步，可以指定不同的策略进行写入和落盘；特别敏感的场景也可以配置Redis绕过操作系统的写文件缓存，防止数据丢失</li>
<li>AOF载入。通过载入AOF文件完成数据还原，相当于事件流架构（Event Architecture and Event Streaming）中使用时间溯源</li>
<li>AOF重写。防止AOF爆炸，实际上是从当前数据库快照去虚拟写入一个key-val的操作，写入到rewrite之后的AOF文件中，这样删除的key就不再有AOF记录，多次修改的key也仅有一个写入AOF记录，从而减小AOF文件大小。通过BGREWRITEAOF后台实现，后台执行时，其它命令的执行还要写入新的AOF记录，在rewrite完成之后再追加这些记录即可</li>
</ul>
<h3 id="数据库通知。"><a href="#数据库通知。" class="headerlink" title="数据库通知。"></a>数据库通知。</h3><ul>
<li>Redis2.8新增的功能，可以让客户端订阅给定的频道或者模式，获知数据库中键的变化和命令的执行情况</li>
<li>发送通知的实现：在相关操作完成后，调用通知函数</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li><p>Redis服务器实际上是一个事件驱动程序，处理两类事件：</p>
<ul>
<li>文件事件。Redis服务器通过套接字与客户端或其它Redis服务器进行连接，文件事件是服务器对套接字操作的抽象。服务器与客户端的通信操作会产生相应的文件事件，服务器通过监听和处理这些事件来完成网络通信操作</li>
<li>时间事件。对Redis服务器中需要定时执行的操作的抽象</li>
</ul>
</li>
<li><p>文件事件。 Redis基于reactor模式实现了自己的网络事件处理器，称为文件事件处理器。</p>
<ul>
<li>使用I/O多路复用程序来同时监听多个套接字，并根据套接字正在执行的任务来为套接字关联不同的时间处理器</li>
<li>当被监听的套接字准备好执行accept、read、write、close等操作时，操作相对应的文件事件就会产生，文件事件处理器随机调用套接字关联好的事件处理器来处理这些事件</li>
<li>Redis自己封装了select，epoll，evport，kqueue等函数库</li>
<li>事件类型：<ul>
<li>当事件变得可读时（客户端对套接字执行write，close操作，或有新的acceptable套接字出现），套接字产生AE_READABLE事件</li>
<li>当事件变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件</li>
<li>先处理读事件，再处理写事件</li>
</ul>
</li>
<li>文件事件处理器<ul>
<li>连接应答处理器。对连接服务器的客户端进行应答</li>
<li>命令请求处理器。接收客户端传来的命令请求。</li>
<li>命令回复处理器。向客户端返回命令执行结果。</li>
<li>复制处理器。主从服务器进行复制操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>时间事件</p>
<ul>
<li>分类<ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
</li>
<li>用一个链表来存储时间事件，实际上一般只有serverCron一个时间事件    - serverCron默认1秒执行10次，它完成一些常见的服务器后台工作：<ul>
<li>更新服务器统计信息，如时间、内存占用等</li>
<li>删除过期key</li>
<li>清理失效链接</li>
<li>尝试AOF和RDB持久化</li>
<li>主从同步</li>
<li>集群心跳测试和同步</li>
</ul>
</li>
</ul>
</li>
<li><p>事件调度与执行</p>
<ul>
<li>注意所有的事件都是同步、有序、原子的执行的，不存在中断事件和事件抢断的问题。</li>
<li>耗时的事件通过子线程后台执行</li>
<li>某些可能耗时的操作提供了主动让出执行权的机制，从而防止饥饿</li>
</ul>
</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>Redis为每个连接创建redisClient结构对象，以链表的形式保存在redisServer中，redisClient保存了当前客户端的状态信息，包括socket、名字、flag、身份验证、输入输出buffer、最后连接时间等</li>
</ul>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li><p>命令请求执行过程</p>
<ul>
<li>客户端发送命令请求<ul>
<li>用户输入命令</li>
<li>按协议格式转换命令</li>
</ul>
</li>
<li>服务器接收并执行命令<ul>
<li>套接字读取到客户端命令请求，将其保存到对应客户端对象的输入缓冲区</li>
<li>事件分派器分发到对应的事件处理器</li>
<li>提取命令、参数、参数个数，分别存到argv和argc参数中</li>
<li>调用命令执行器，执行命令</li>
<li>命令执行器（一）根据客户端传来的命令名，从命令字典查找实现命令RedisCommand对象</li>
<li>命令执行器（二）执行预备操作</li>
<li>命令执行器（三）调用命令的实现函数，包括映射到具体数据结构的操作命令</li>
<li>命令执行器（四）添加AOF记录、慢日志、replication广播等</li>
</ul>
</li>
<li>服务器返回执行结果<ul>
<li>写入输出缓冲区，通过命令回复处理器发送命令回复。</li>
<li>客户端接收并输出执行结果<ul>
<li>从服务器获取到协议格式的回复</li>
<li>解析回复并输出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ServerCron</p>
<ul>
<li>更新服务器时间缓存。Redis保存有一个时间缓存，用于一些对时间精度要求不高的场景使用该缓存，减小获取时间系统调用，serverCron要定期更新这个缓存</li>
<li>更新LRU时钟。lruclock是一个估算值，因此使用定时更新的方式处理，每10s处理一次</li>
<li>更新服务器每秒执行命令数。通过1/1000抽样估算每秒执行命令数</li>
<li>更新服务器内存峰值。</li>
<li>处理SIGTERM信号，优雅退出</li>
<li>管理客户端资源。释放超时链接等</li>
<li>管理数据库资源。删除过期键等</li>
<li>执行被延迟的BGREWRITEAOF</li>
<li>FLUSH AOF缓冲区</li>
</ul>
</li>
<li><p>初始化服务器</p>
<ul>
<li>初始化服务器状态结构。创建redisServer数据结构，并初始化一些默认配置</li>
<li>载入配置。</li>
<li>初始化服务器数据结构。server.clients链表、server.db数组、共享对象、打开AOF文件等</li>
<li>还原数据库状态。从AOF或RDB文件恢复数据库</li>
<li>执行事件循环。开启事件while-true循环</li>
</ul>
</li>
</ul>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><ul>
<li>redis multi databases的意义？schema用于在某些场景替代新增节点或不必要的集群化，从而简化更多节点或集群化的监控和管理成本。<a href="https://stackoverflow.com/questions/16221563/whats-the-point-of-multiple-redis-databases" target="_blank" rel="external">https://stackoverflow.com/questions/16221563/whats-the-point-of-multiple-redis-databases</a></li>
<li>redis服务器实质上是一个事件处理循环，并且尽可能的使用单进程、单线程、顺序阻塞的模式处理文件事件和时间事件，降低了系统的复杂度，且由于redis通过IO多路复用、内存方面的高效，这种模式也没有对响应速度造成影响。</li>
</ul>
<h2 id="redis设计与实现笔记（三）：集群数据库实现"><a href="#redis设计与实现笔记（三）：集群数据库实现" class="headerlink" title="redis设计与实现笔记（三）：集群数据库实现"></a>redis设计与实现笔记（三）：集群数据库实现</h2><h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><ul>
<li>Redis2.8以前不能高效的处理断线后复制的情况，2.8的部分重同步功能解决</li>
<li>部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分实现</li>
<li>主服务器向从服务器传播命令来更新从服务器状态，保持主从一致</li>
<li>从服务器向主服务器发送心跳，以及检测命令丢失</li>
</ul>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><ul>
<li>Sentinel是Redis高可用性high availability的解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器及其所有从服务器。能够在主服务器下线时，自动将下线主服务器对应的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。<ul>
<li><ol>
<li>Sentinel只是一个运行在特殊模式下的Redis服务器，它使用了和普通模式不同的命令表</li>
</ol>
</li>
<li><ol>
<li>Sentinel会读入用户指定的配置文件，为每个要监视的主服务器创建相应的实例结构，并创建连接向主服务器的命令连接和订阅连接，命令连接用于向主服务器发送命令请求，订阅连接用于接收指定频道的消息</li>
</ol>
</li>
<li><ol>
<li>Sentinel通过向主服务器发送INFO命令，获得主服务器下所有从服务器列表，为这些从服务器创建实例结构、命令连接和订阅连接</li>
</ol>
</li>
<li><ol>
<li>一般情况下，Sentinel以10s一次频率向被监视的服务器发送INFO命令，当主服务器处于下线状态或故障转移状态时，频率提高到1s一次</li>
</ol>
</li>
<li><ol>
<li>监视同一个服务器的多个sentinel，会以2s一次的频率向被监视服务器的<strong>sentinel</strong>:hello频道发送消息向其它Sentinel宣告自己的存在</li>
</ol>
</li>
<li><ol>
<li>Sentinel与Sentinel之间只创建命令连接</li>
</ol>
</li>
<li><ol>
<li>Sentinel以1s一次的频率向其它实例（主服务器、从服务器、其它Sentinel）发送PING请求，当连续PING不通时Sentinel会将这个实例判定为主观下线</li>
</ol>
</li>
<li><ol>
<li>当Sentinel判定一个主服务器下线时，它会向其它监视这个主服务器的Sentinel询问，看它们是否同意主观下线</li>
</ol>
</li>
<li><ol>
<li>当收集足够多的主观下线投票时，Sentinel会判定服务器客观下线，随后发起故障转移操作</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul>
<li>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）进行数据共享，并提供复制和故障转移功能。</li>
<li><p>集群节点</p>
<ul>
<li>使用MEET命令将某个目标服务器加入当前服务器所在的集群，需要在Redis启动前开启cluster-enabled选项</li>
<li>除了集群模式下特有的数据结构clusterNode、clusterLink、clusterState，还会完整使用单机模式下的所有结构和功能</li>
<li>MEET命令实现上，就是两个节点通信，并分别在本地为对方创建clusterNode数据结构</li>
</ul>
</li>
<li><p>槽指派</p>
<ul>
<li>槽slot相当于数据分片，0-16383个槽必须全部分配到某个节点上，且处于服务状态，集群才可用。使用CLUSTER ADDSLOT手动指派槽</li>
<li>槽指派信息用一个bitmap（2048个字节的位数组）来记录，且不同节点的信息会互相同步到集群所有节点的clusterNode对象保存</li>
<li>clusterState中还要反向记录一个slot-node的映射信息（槽指派信息）</li>
<li>CLUSTER ADDSLOTS实现：检查slots是否被占用，若没被占用就分别更新和传播clusterState.slots和slotbit信息</li>
<li>key-&gt;槽映射。CRC16(key) &amp; 16383</li>
<li>重新分片。Redis的集群管理工具redis-trib进行了封装。基本原理是一个一个节点处理，在目标服务器写入slots相关数据，在原服务器删除slots相关数据，并完成数据迁移</li>
<li>重新分片的数据迁移过程中，可能出现同样的slot，有的key在原服务器上，有的key在目标服务器上，这时候通过slot-to-key数据结构可以进行错误提示或命令重定位（ASK错误）</li>
</ul>
</li>
<li><p>复制与故障转移</p>
<ul>
<li>主从节点各有相关的标志位来标示，从节点的clusterNode结构中保存了指向主节点的指针</li>
<li>通过PING来互相获知其它节点的服务状态，并互相同步/报告下线的服务器（创建新的clusterNodeFailReport结构），当半数以上主节点认为某个主节点疑似下线，集群就会广播其客观下线的消息，并触发故障转移</li>
<li>故障转移步骤：选出新的主节点候选-&gt;候选设置主节点标记正式成为主节点-&gt;迁移已下线主节点的slot信息到新的主节点-&gt;新主节点向集群广播PONG消息，表明自己正式成为主节点-&gt;新的主节点开始处理自己负责的槽对应的相关命令</li>
<li>主节点选举。由其它主节点投票，从节点向所有其它主节点发送消息，当收到确认后，对应的主节点就投了发送消息的从节点一票（结果似乎谁先发声谁占优势），获得N/2+1及以上个投票的从节点会成为新的主节点。涉及算法：Raft算法的领头选举方法leader election</li>
</ul>
</li>
<li><p>消息。集群中的节点通过message来通信，一个message包括header和data两个部分，主要有5种消息：</p>
<ul>
<li>MEET。请求receiver加入sender所在的集群</li>
<li>PING。随机发送PING消息到某个已知节点，若超过一定阈值没发送也会发送（防止随机产生饥饿）</li>
<li>PONG。用于响应MEET或PING，也用于直接向集群其它节点广播当前状态，比如故障转移时选举出来的主节点准备好后，向集群确认自己成为主节点</li>
<li>FAIL。向集群广播某主服务器下线</li>
<li>PUBLISH。广播某个命令</li>
</ul>
</li>
</ul>
<h2 id="redis设计与实现笔记（四）：独立功能"><a href="#redis设计与实现笔记（四）：独立功能" class="headerlink" title="redis设计与实现笔记（四）：独立功能"></a>redis设计与实现笔记（四）：独立功能</h2><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><ul>
<li>支持发布/订阅、模式订阅（PUBLISH/SUBSCRIBE/PSUBSCRIBE）</li>
<li>redisServer结构中保存有频道订阅关系的dict结构，pubsub_channels</li>
<li>SUBSCRIBE命令就是向pubsub_channels字典的某个频道对应的链表（没有则创建）添加自己的服务器，UNSUBSCRIBE正好相反</li>
<li>模式订阅用另一个数据结构pubsub_patterns链表来存储</li>
<li>PSUBSCRIBE命令向pubsub_patterns链表添加新的节点，UNPSUBSCRIBE相反</li>
<li>发送消息时，需要分别向channel和其匹配pattern的订阅者发送消息。<ul>
<li>向channel发送消息时，遍历channel下的订阅方链表，逐个向subscriber发送消息</li>
<li>向pattern发送消息时，遍历pattern链表，找到所有跟channel匹配的的subscriber，逐个发送消息</li>
</ul>
</li>
<li>查看订阅信息PUBSUB命令，查询相关结构并打印数据</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>基本流程<ul>
<li>Redis使用MULTI、EXEC、WATCH等命令实现事务功能。</li>
<li>MULTI命令开启事务模式，在事务模式下，不属于MULTI//EXEC/WATCH/DISCARD的命令不会被马上执行，而是加入到事务队列中</li>
<li>redisClient.multiState用FIFO队列记录了等待被事务执行的命令列表</li>
<li>服务器端收到EXEC命令后，会按顺序执行队列中的命令，并将每个命令的执行结果加入结果队列，最后重置事务状态，返回执行结果队列</li>
</ul>
</li>
<li>WATCH<ul>
<li>WATCH是一个乐观锁，用于监视一个或多个指定的key，当key发生变化时，服务器会拒绝执行事务</li>
<li>被监视的key用redisDB.watched_keys字典存储</li>
<li>监视触发。写命令（PUSH、SET、SADD等）执行后，会通过watched_keys字典检查当前key是否被监视，如果被监视，就将监视key的客户端的REDIS_DIRTY_CAS标记打开，表示该客户端的事务安全性已被破坏</li>
</ul>
</li>
<li>ACID。传统数据库中，唱唱用ACID检验事务功能的可靠性和安全性<ul>
<li>Atomicity。原子性上，Redis满足要么全执行，要么全不执行的准则，但是不支持回滚机制，如果有一个命令执行错误，剩余的命令也会被完整的执行。作者antirez在事务的文档中解释为回滚这种复杂的功能和Redis追求的简单高效的设计主旨不相符，而且他认为，Redis事务的执行时错误通常都是编码问题导致的，生产环境很少遇到这种问题。</li>
<li>Consistency。一致性上，WATCH命令可以控制脏读脏写，入队错误、执行错误和服务器停机异常场景都进行了覆盖，不会产生非法或无效错误数据</li>
<li>Isolation。隔离性上，Redis是单线程执行事务和命令的，也不会在事务执行期间中断事务，因此Redis事务总是以串行方式执行的，并且也总是有隔离性的</li>
<li>Durability。Redis事务没有涉及单独的持久化逻辑，如果有必要可以在事务中手动加入SAVE命令，但是这样做效率太低，不具有实用性</li>
</ul>
</li>
</ul>
<h3 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h3><ul>
<li>Lua脚本是一个小巧的脚本语言，一个完整的Lua解释器不超过200k，由C语言写成，设计目的是为了嵌入应用程序，使应用程序可以灵活的扩展和定制功能。</li>
<li>Redis使用Lua的目的和场景<ul>
<li>减小网络开销。一次性传输多个命令，且脚本存储到服务器端，可以重复调用</li>
<li>原子操作。</li>
<li>源码小巧、速度快、可移植</li>
<li>模块化一些常用操作</li>
<li>一些redis使用Lua的场景。限流：<a href="https://www.cnblogs.com/yanghuahui/p/3697996.html" target="_blank" rel="external">https://www.cnblogs.com/yanghuahui/p/3697996.html</a> 库存：<a href="https://www.cnblogs.com/yanghuahui/p/3697996.html" target="_blank" rel="external">https://www.cnblogs.com/yanghuahui/p/3697996.html</a></li>
</ul>
</li>
<li>Redis启动时会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足redis在功能性、安全性等方面的需求</li>
<li>Redis服务器专门使用一个伪客户端执行Lua脚本中包含的Redis命令</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>SORT可以对列表、集合、有序集合进行排序，底层使用快速排序算法。</li>
<li>SORT <key> 实现<ul>
<li>创建一个redisSortObject结构数组tmp[]，并将数组tmp[]的元素指向要排序的列表的元素O(N)</li>
<li>计算并写入每个tmp[]数组项的double评分score O(N)</li>
<li>tmp[]按值进行排序</li>
<li>按tmp[]顺序，获取原数组的元素组成返回结果</li>
</ul>
</key></li>
<li>ALPHA选项实现。上述sort <key>的实现中，第三步值排序换成字符串排序</key></li>
<li>ASC/DESC调整。调节排序过程中的排序比对算法即可</li>
<li>BY实现。根据模式找出相应的值，并调整排序过程</li>
<li>LIMIT实现。</li>
<li>GET选项实现。（这里Foreign Key形式的松散对象的模型看着有些别扭）</li>
<li>STORE选项。将排序结果存储到一个指定的key中，以复用结果</li>
</ul>
<h3 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h3><ul>
<li>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令来操作位数组</li>
<li>SETBIT、GETBIT算法比较简单，通过X/8和X%8+1找到对应的字节对应的位完成读写操作即可</li>
<li>BITCOUNT则要复杂一些，下面罗列常见的算法：<ul>
<li>遍历。不具体阐述，复杂度O(N)</li>
<li>查表法。按字节或多个字节创建不同字节到BITCOUNT的表，例如，用一个字节来创建表，可以一次获知1000 0000的BITCOUNT是1，对每个字节进行操作再求和，算法复杂度直接降到O(N/8)。扩大表的范围（2个以上字节）理想情况下能更多的提升性能O(N/x*8)，但是受限于内存，CPU缓存，实际上不容易实现，效果也没有保证</li>
<li>variable-precision SWAR算法。数学上对于BITCOUNT的过程称为计算Hamming Weight。Hamming Weight经常被用于信息论、编码理论、密码学，所以有很多算法，variable-precision SWAR是目前最好的算法。它本质上是个分治divide-conquer算法，所以能拿到O(logN)的复杂度。实际上使用时，如果循环四次，一次拿到一个4字节32位的Hamming-Weight再循环相加，最终的复杂度是O(N/32*4)</li>
<li>Redis实现。8位表+四次variable-precision SWAR循环算法一次性计算128位的BITCOUNT</li>
</ul>
</li>
<li>BITOP在进行AND/OR/XOR操作时，会创建一个新的数组保存结果。</li>
</ul>
<h3 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h3><ul>
<li>Redis慢日志记录执行时间超过指定时长的命令</li>
<li>慢日志并没有打印到日志文件，而是保存到redisServer结构的slowlog链表，可以用SLOWLOG GET查询</li>
<li>新日志添加表头，当链表长度超过最大值时从表尾删除</li>
<li>执行命令前后都会获取UNIX时间戳，并用slowlogPushEntryIfNeeded来处理<br>监视器</li>
<li>通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时的接收并打印服务器当前处理的命令相关信息</li>
<li>redisServer维护了一个监视器列表数据结构monitors链表</li>
<li>一个monitor实质上是一个redis-client，有一个client.flags&amp;REDIS_MONITOR = REDIS_MONITOR标志位</li>
<li>命令执行前有一个replicationFeedMonitors函数来向监视器发布信息</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/笔记：redis设计与实现/" data-id="cjr4jact600013xfy7k6hw7b5" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术内幕/">技术内幕</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-常见设计模式总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/常见设计模式总结/" class="article-date">
  <time datetime="2019-01-20T01:00:07.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/常见设计模式总结/">常用设计模式总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>注意的点：<ul>
<li>私有构造方法</li>
<li>静态对象+静态方法</li>
<li>线程安全性，不能重复创建（类初始化时就加载没有线程安全性问题）</li>
<li>性能，减小锁的使用</li>
</ul>
</li>
<li>代码：<pre><code><br>public class Singleton{<br>  private static volatile Singleton s = null;<br>  private static final ReentrantLock LOCK = new ReentrantLock();<br>  public static Singleton get(){<pre><code>if(s==null){
    try{
        if(LOCK.lock()){
            if(s==null){
                   s = new Singleton();
               }
        }
    }
}
return s;
</code></pre>  }<br>}<br></code></pre></li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul>
<li>注意的点：<ul>
<li>工厂接收传入的参数，返回一个接口对应的多个实现类的其中一个实例</li>
<li>扩展：结合单例<br>优点：</li>
<li>按接口规范调用产品对象的所有功能方法</li>
<li>使用方不需要关心实现细节，构造容易，逻辑简单<br>缺点：</li>
<li>全部if-else hard code，增减类型的时候都需要修改代码，对系统的维护可扩展不利。违反“开放-关闭原则”</li>
<li>所有类的实例创建逻辑都集中到一个工厂类中，违反“高内聚责任分配原则”</li>
</ul>
</li>
<li><img src="../images/design-pattern-simple-factory.png" alt="image"></li>
<li>代码示例：<pre><code><br>public interface IProduct{<br>  void A();<br>  void B();<br>}</code></pre></li>
</ul>
<p>public class Product1 implements IProduct{<br>    public void A(){}<br>    public void B(){}<br>}<br>public class Product2 implements IProduct{<br>    public void A(){}<br>    public void B(){}<br>}</p>
<p>public class ProductFactory{<br>    public static IProduct create(String name){<br>        if(P1.equals(“1”)){<br>            return new Product1();<br>        }else if(P2.equals(“2”)){<br>            return new Product2();<br>        }else{<br>            return null;<br>        }<br>    }<br>}<br></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul>
<li>注意的点<ul>
<li>在简单工厂方法的基础上，将产品的创建从简单的单一工厂，拆分成多个实例工厂</li>
<li>保留了简单工厂方法封装对象创建细节的特点的同时，解决了简单工厂扩展维护苦难的问题</li>
</ul>
</li>
<li>类划分：<ul>
<li>抽象产品/产品接口</li>
<li>具体产品/产品实现类</li>
<li>抽象工厂</li>
<li>真实工厂</li>
</ul>
</li>
<li>优点：<ul>
<li>减少了单一工厂负责所有对象创建逻辑的耦合度</li>
<li>符合“开放-关闭原则”，增减新的类型，只需要增加/删除相应的工厂类和产品类即可</li>
<li>符合符合迪米特原则：又叫最少知识原则，即一个对象应尽可能少的了解其它对象。</li>
<li>符合里式替换原则：任何基类可以出现的地方，一定可以用子类替换。目标是使用抽象和多台将设计中的静态结构改为动态结构</li>
</ul>
</li>
<li><img src="../images/design-pattern-factory-method.png" alt="image"></li>
<li>代码示例<pre><code><br>public interface IProduct(){<br>  void A();<br>}<br>public interface IFactory(){<br>  IProduct createProduct();<br>}<br>public class Product1() implements IProduct{<br>  public void A(){}<br>}<br>public class Product2() implements IProduct{<br>  public void A(){}<br>}<br>public class Factory1() implements IFactory1{<br>  public IProduct createProduct(){<pre><code>return new Product1();
</code></pre>  }<br>}<br>public class Factory2() implements IFactory2{<br>  public IProduct createProduct(){<pre><code>return new Product2();
</code></pre>  }<br>}<br>public class Client{<br>  public static void main(String[] args){<pre><code>Factory1 f1 = new Factory1();
IProduct p1 = f1.createProduct();
Factory2 f2 = new Factory2();
IProduct p2 = f2.createProduct();
</code></pre>  }<br>}<br></code></pre></li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><ul>
<li>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的类</li>
<li>区别于工厂方法模式：工厂方法针对一个产品等级结构（一个产品接口/基类），而抽象工厂模式针对多个产品等级结构。举例来说，当需要通过工厂来管理男人/女人/女博士一个维度的产品分类对象时，可以使用工厂方法模式；而如果出了男人/女人/女博士一个维度，还要管理黄/黑/白三个肤色人种，或者再加一种基督/佛教/锡克教等宗教维度，就可以用到抽象工厂模式。</li>
<li>缺点：<ul>
<li>上层维度（产品族）扩展非常困难。底层维度扩展时，只需要直接新增产品类和产品工厂类；而上层维度扩展首先要修改IFactory，违反“开放-关闭原则”</li>
</ul>
</li>
<li><img src="../images/design_pattern_abstract_factory.png" alt="image"></li>
<li>代码示例<pre><code><br>//以下是个苹果专卖店和三星专卖店分别销售手机和平板的例子<br>//大家可以假设富士康开了两条不同的流水线，分别生产苹果产品和三星产品，自己写一个不同维度的工厂方法组织方式<br>public interface Mobile{<br>  void makeCall();<br>}<br>public interface Pad{<br>  void game();<br>}<br>public interface DigitSellerFactory{<br>  Mobile sellMobile();<br>  Pad sellPad();<br>}<br>public class IPhone implements Mobile{<br>  public void makeCall(){}<br>}<br>public class Note2 implements Mobile{<br>  public void makeCall(){}<br>}<br>public class IPad implements Pad{<br>  public void game(){}<br>}<br>public class Tab implements Pad{<br>  public void game(){}<br>}<br>public class AppleSeller implements DigitSellerFactory{<br>  public Mobile sellMobile(){<pre><code>return new IPhone();
</code></pre>  }<br>  public Pad sellPad(){<pre><code>return new IPad();
</code></pre>  }<br>}<br>public class SumsungSeller implements DigitSellerFactory{<br>  public Mobile sellMobile(){<pre><code>return new Note2();
</code></pre>  }<br>  public Pad sellPad(){<pre><code>return new Tab();
</code></pre>  }<br>}<br></code></pre></li>
</ul>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><ul>
<li>子类集成的方法对于功能多样化的扩展是极为不利的，除了功能多样难于管理，不同功能之间的组装更是有着不可计数的可能性。</li>
<li>注意的点：<ul>
<li>动态扩展</li>
<li>不改变原有的类</li>
<li>不用生成子类的继承方式</li>
<li>Decorator的功能通常不能有关联关系</li>
</ul>
</li>
<li>核心组件：<ul>
<li>原始类接口</li>
<li>原始类的基础实现</li>
<li>装饰器接口（一般类或抽象类）</li>
<li>继承装饰器接口的一系列具体装饰器</li>
</ul>
</li>
<li><img src="../images/design-pattern-decorator.png" alt="image"></li>
<li>代码示例<pre><code><br>public interface Phone{<br>  void func();<br>}<br>public class BasePhone implements Phone{<br>  public void func(){<pre><code>System.out.println(&quot;make call&quot;);
</code></pre>  }<br>}<br>public abstract class PhoneDecorator implements Phone{<br>  private Phone phone;<br>  public void func(){<pre><code>phone.func();
decoration();
</code></pre>  }<br>  public abstract void decoration();<br>}<br>public class  GameDecorator extends PhoneDecorator{<br>  public void decoration(){<pre><code>System.out.println(&quot;game!!!&quot;);
</code></pre>  }<br>}<br>public class ShuangKaShuangDaiDecorator extends PhoneDecorator{<br>  public void decoration(){<pre><code>System.out.println(&quot;shuang ka shuang dai!!!&quot;);
</code></pre>  }<br>}<br>public class Main{<br>  public static void main(String[] args){<pre><code>Phone basePhone = new BasePhone();
basePhone.func();
Phone gamePhone = new GameDecorator(basePhone);
gamePhone.func();
Phone shuangkaPhone = new ShuangkaShuangDaiDecorator(basePhone);
shuangkaPhone.func();
Phone shuangkaGamePhone = new ShuangkaShuangDaiDecorator(gamePhone);
shuangkaGamePhone.func();
</code></pre>  }<br>}<br></code></pre></li>
</ul>
<h2 id="观察者模式-发布-订阅模式"><a href="#观察者模式-发布-订阅模式" class="headerlink" title="观察者模式/发布-订阅模式"></a>观察者模式/发布-订阅模式</h2><ul>
<li>定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题对象，当这个主题对象发生变化时，会通知所有观察者对象，使他们可以自动更新自己<br>注意的点：<ul>
<li>多个观察者主动加入监听，被监听对象不关心有多少观察者，低耦合</li>
<li>被监听对象发通知，观察者自己接收通知并完成后续处理</li>
<li>观察者可以主动注册和撤销监听</li>
<li>避免循环引用，观察者一般要异步去完成后续处理<br>优点：</li>
<li>观察者和被观察者是抽象耦合的，有一套触发机制<br>缺点：</li>
<li>观察者过多时，通知耗时</li>
<li>观察者只知道状态变化，不知道状态变化的过程</li>
</ul>
</li>
<li><img src="../images/design-pattern-decorator.png" alt="image"></li>
<li><pre><code>
public class Subject{
  private List<observer> observers;
  private int state;
  public void subscribe(Observer observer){
      observers.add(observer);
  }
  public void unsubscribe(Observer observer){
      observers.remove(observer);
  }
  public void notifyAll(){
      observers.foreach(x -> {
          x.update()
      })
  }
}
public abstract class Observer{
  protected Subject subject;
  public abstract void update();
}
</observer></code></pre>

</li>
</ul>
<h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><ul>
<li>将应用程序切分为Model/View/Control三类核心组件，它们各自处理自己的任务<ul>
<li>模型：持有数据、状态和程序逻辑</li>
<li>视图：用来呈现模型</li>
<li>控制器：负责接收用户输入、解析输入并返回给模型</li>
<li>MVC通过观察者模式实现视图和模型的分离，当Model数据发生变化时，通知到其相关的所有View</li>
<li>MVC通过策略模式将视图行为委托到Controller，并实现了视图行为的灵活切换</li>
</ul>
</li>
<li>优点：<ul>
<li>一个模型可以由不同的视图展示，模型数据发生变化时，模型将通知它对应的视图</li>
<li>模型可复用</li>
<li>提高开发效率</li>
</ul>
</li>
</ul>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul>
<li>命令模式是一种数据驱动的设计模式，它属于行为模式。它将请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适对象，并把命令传递给相应的对象，该对象执行命令。</li>
<li>主要组件：<ul>
<li>被操作实体类</li>
<li>命令接口</li>
<li>命令实现类（含被操作的实体类的组件）</li>
</ul>
</li>
<li>命令接收与处理</li>
<li><code><pre><br>public interface ICommand{<br>  void execute();<br>}<br>public class Entity{<br>  public void op1(){}<br>  public void op2(){}<br>}<br>public class op1OnEntity implements ICommand{<br>  private Entity entity;<br>  public void execute(){<pre><code>entity.op1();
</code></pre>  }<br>}<br>public class op2OnEntity implements ICommand{<br>  private Entity entity;<br>  public void execute(){<pre><code>entity.op2();
</code></pre>  }<br>}<br>public class Broker{<br>  private List<icommand> toDoOperations;<br>  public void receiveCommand(ICommand c){<pre><code>toDoOperations.add(c);
</code></pre>  }<br>  public void doCommand(){<pre><code>toDoOperations.foreach(x -&gt; x.execute());
</code></pre>  }<br>}<br></icommand></pre></code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/常见设计模式总结/" data-id="cjr4jact200003xfyazu37tmr" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-笔记——《ElasticSearch技术内幕》" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/笔记——《ElasticSearch技术内幕》/" class="article-date">
  <time datetime="2019-01-20T00:00:07.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/笔记——《ElasticSearch技术内幕》/">笔记——《ElasticSearch技术内幕》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ElasticSearch的设计理念"><a href="#ElasticSearch的设计理念" class="headerlink" title="ElasticSearch的设计理念"></a>ElasticSearch的设计理念</h2><ul>
<li>合理的默认配置，使用户简单安装之后就可以直接使用，例如有了dynamic mapping，基本上就不需要再单独写mappings</li>
<li>默认分布式工作模式。每个节点总是假设自己属于某个集群</li>
<li>集群易于伸缩</li>
<li>对数据结构没有任何限制</li>
<li>准实时+版本同步</li>
</ul>
<h2 id="ES工作流程"><a href="#ES工作流程" class="headerlink" title="ES工作流程"></a>ES工作流程</h2><ul>
<li>启动过程。所有节点通过广播/单播组件结成集群，并选举产生master节点。master节点负责集群的状态管理及拓扑变化（集群伸缩时的分片迁移）</li>
<li>故障检测。master节点向其它节点发送心跳检测，当发生故障时，master就会启动拓扑更新和分片数据转移，保证集群的正常工作</li>
<li>索引数据。构建索引只会在master节点完成，再同步shard到不同的其它节点</li>
<li>查询数据。包括分散阶段scatter phase和合并阶段gather phase两个阶段。分散阶段将query分发到不同的分片完成查询（这里也起到了负载均衡的作用），合并阶段收集各分片上的搜索结果，进行合并、排序、后续处理并返回给客户端</li>
</ul>
<h2 id="底层索引控制"><a href="#底层索引控制" class="headerlink" title="底层索引控制"></a>底层索引控制</h2><ul>
<li>lucene 4.0支持了多种相似度计算模型（相似度是指查询向量同某个文档的余弦匹配度）。除了传统的TF/IDF，还有Okapi BM25、随机偏离、基于信息的模型几种。不同的field可以配置不同的相似度计算策略</li>
<li>索引文件编解码方式。通过配置不同的编解码方式，可以控制压缩程度和高基字段的预加载，从而在查询速度和内存之间做权衡</li>
<li>索引可见流程。<ul>
<li>索引更新与提交过程。Lucene在接收新的Document之后，在索引变得可见之前，还要经过以下几个阶段：①document处理（类型映射等）②创建只读的Segment_N文件（commit操作）③Searcher刷新（Searcher需要重新打开才能看到新索引，默认1s刷新）。可以看到，从lucene开始处理索引，到索引可以被查询到，有1s左右的延迟，这也是lucene/ES自称为准实时系统的原因</li>
<li>事务日志。因为不能频繁提交，所以遇到错误时有些数据可能会从内存中丢失，ES使用事务日志来记录所有的未提交事务，在发生错误时检查事务日志，执行未完成的操作。VSearch中似乎抽象了checkpoint的概念，跟写事务日志类似</li>
<li>准实时读取。可以通过使用事务日志，将提交的事务也进行查询，从而获取未提交版本的数据</li>
</ul>
</li>
<li>索引合并的3种策略。force merge操作</li>
</ul>
<h2 id="分布式索引架构"><a href="#分布式索引架构" class="headerlink" title="分布式索引架构"></a>分布式索引架构</h2><ul>
<li>问题<ul>
<li>如何为集群选择合适的shard和replication数量</li>
<li>什么是路由</li>
<li>分片分配器</li>
<li>如何应对数据和查询的增长</li>
</ul>
</li>
<li>实现<ul>
<li>将一个索引切分成若干个小索引，以便在同一集群的不同节点上分配它们，实现查询的并发处理。ES默认将每个索引分成5个shards，并做1个replication。即使是只有1个节点，这样做也可以方便扩容</li>
<li>一般来说，N个节点的集群，切分为N个分片+1个replication，总共2N个分片，可以最大化集群的分布式优势。但是这不是绝对的，因为查询过程的scatter phase和gather phase也是有代价的，有些时候（比如数据少的时候、有明确路由规则的时候）</li>
<li>路由类似mysql的分库分表过程，使用统一的分片规则和查询规则，可以实现只在特定分片上查询，从而避免不必要的scatter&amp;gather过程。例如按用户对订单数据进行分片，查询某个用户就能映射到某一特定分片，在这一个分片上查询即可<ul>
<li>不指定路由规则时。es会自动查询所有分片，修改或删除某一分片时也要定位到特定分片，所以只要保证一个id对应的document一直生成相同的值即可</li>
<li>指定路由规则。在mapping中添加_mappings字段，指定任意一个未分词的字段即可。要确保对同一个document，始终能计算得出一个相同的routing值</li>
</ul>
</li>
</ul>
</li>
<li>分片分配机制。<ul>
<li>当集群拓扑发生改变时，ShardAllocator负责分片的再分配。同一分片的primary shard和replication shard不能分配到同一节点（多于一个节点时）。分配机制会考虑多种因素：磁盘空间、同一分片的安全性、节点包含的同一个索引的分片数等</li>
<li>even_shard分配。保证每个节点有相同的分片数</li>
<li>balanced分配。提供一些可控参数交由用户控制</li>
<li>可以自行实现ShardAllocator接口</li>
</ul>
</li>
<li>ES集群跟redis集群的一点区别<ul>
<li>ES集群所有节点都可以配置为master候选节点，当master节点故障时其它节点会选举出新的master节点，并进行分片数据迁移</li>
<li>Redis集群是所有master节点不可或缺，系统不会因为节点故障修改master节点管理的slot，当遇到故障时，master节点对应的replication/slave节点就会选举出新的master节点加入集群</li>
</ul>
</li>
</ul>
<h2 id="管理ElasticSearch"><a href="#管理ElasticSearch" class="headerlink" title="管理ElasticSearch"></a>管理ElasticSearch</h2><ul>
<li>目标：<ul>
<li>选择正确的目录实现，提升底层I/O效率</li>
<li>配置发现模块避免潜在问题</li>
<li>配置网关模块</li>
<li>恢复模块</li>
<li>查看段信息</li>
<li>ES缓存</li>
</ul>
</li>
<li>存储类型：<ul>
<li>SimpleFSDirectory。简单文件存储系统</li>
<li>NIOFSDirecotyr。NIO文件存储。linux上默认使用nio</li>
<li>MMapDirectory。文件映射。</li>
<li>内存索引。小索引，有备份数据支持重建时使用。</li>
</ul>
</li>
<li>发现模块：<ul>
<li>multicast（Zen）</li>
<li>unicast。向配置指定的服务器列表进行单播，减少不必要流量</li>
</ul>
</li>
<li>最小主节点数<ul>
<li>至少N/2+1，防止split brain</li>
</ul>
</li>
<li>网关</li>
<li>索引段统计<ul>
<li>可以通过API查看索引/分片/段信息</li>
</ul>
</li>
<li>ES缓存<ul>
<li>过滤器缓存。缓存filter查询结果，LRU策略。</li>
<li>字段数据缓存。主要用于aggregation</li>
<li>使用API可以清楚特定缓存</li>
</ul>
</li>
</ul>
<h2 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h2><ul>
<li>垃圾处理器。java8引入了G1，G1主要目标是减少暂停，使用户感受不到卡顿，但是吞吐量比较差，目前默认还是Paralllel</li>
<li>避免内存交换。可以通过配置关闭。</li>
<li>I/O调节。限制每秒的I/O量，防止卡顿</li>
<li>预热器。空间换时间的操作，指定一个查询/aggregation，缓存其结果，提升查询效率。可以单独创建，也可以在indexing时实时更新</li>
</ul>
<h2 id="分片内部原理"><a href="#分片内部原理" class="headerlink" title="分片内部原理"></a>分片内部原理</h2><ul>
<li>如何使文本可搜索：<ul>
<li>段一旦生成就不能再改变</li>
<li>ES在lucene基础上引入了“按段搜索”的概念，这样新增的数据就可以通过建立新的段从而尽快变得可搜索</li>
<li>为了提升索引速度，ES索引的数据先写入memory buffer。ES定期commit生成新的段（行程一个commit point）</li>
<li>commit之后，ES要refresh Searcher之后索引才能对搜索可见</li>
<li>commit之后，新生成的段文件还处在文件缓冲区，没有真正落盘，需要使用fsync()来完成落盘操作</li>
<li>fsync因为IO调用会很慢，fsync也是定期执行完成落盘的。</li>
<li>因为fsync定期完成，当系统异常退出时，未落盘的文件会丢失。所以ES还有translog机制，将未落盘的事件记录文件日志，当出现系统异常时，系统会从translog完成未落盘的索引的恢复工作</li>
<li>translog的落盘也是定期执行的，同样有丢失的可能，用户可以根据使用场景，容忍部分可能的丢失场景。根据kafka的落盘原理，顺序日志落盘其实并不慢</li>
</ul>
</li>
</ul>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ul>
<li>coordinate节点有没有单点故障问题，客户端的角色，负责负载均衡，请求分发等。设置在同一个域名下设置多个coordinate节点做负载均衡避免单点故障问题。</li>
<li>为什么是准实时的？除了数据落盘、filebeat轮询传送事件、logstash处理事件过程的时间消耗，ES处理完document之后，还要暂存document缓存区，commit轮询生成新的段文件，新的段要经过Refresh Searcher操作，才能对客户端可见。</li>
<li>shard在索引创建之前就已确定，如何扩容？增加replica数量</li>
<li>了解一下scatter-gather过程。是否带routing两种情况，不带就遍历，带了可以定位到指定索引，完成scatter搜索，再进行结果的合并</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/笔记——《ElasticSearch技术内幕》/" data-id="cjr4jacth00033xfyxpsolvo8" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术内幕/">技术内幕</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevOps/">DevOps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PAXOS/">PAXOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polyglot/">Polyglot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOA/">SOA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bigdata/">bigdata</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/classloader/">classloader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell-linux-ops/">shell,linux,ops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术内幕/">技术内幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户触达/">用户触达</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维-DevOps/">运维,DevOps</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/DevOps/" style="font-size: 10px;">DevOps</a> <a href="/tags/PAXOS/" style="font-size: 10px;">PAXOS</a> <a href="/tags/Polyglot/" style="font-size: 10px;">Polyglot</a> <a href="/tags/SOA/" style="font-size: 10px;">SOA</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/classloader/" style="font-size: 10px;">classloader</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/shell-linux-ops/" style="font-size: 10px;">shell,linux,ops</a> <a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/技术内幕/" style="font-size: 15px;">技术内幕</a> <a href="/tags/用户触达/" style="font-size: 10px;">用户触达</a> <a href="/tags/笔记/" style="font-size: 20px;">笔记</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/运维-DevOps/" style="font-size: 10px;">运维,DevOps</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/06/翻译：成为多语种的程序员（Being a Polyglot Programmer）/">翻译：成为多语种的程序员（Being a Polyglot Programmer）</a>
          </li>
        
          <li>
            <a href="/2019/02/10/java classloader/">java classloader详解</a>
          </li>
        
          <li>
            <a href="/2019/02/06/redis实践/">redis实践</a>
          </li>
        
          <li>
            <a href="/2019/01/27/SOA方法论/">SOA架构总结</a>
          </li>
        
          <li>
            <a href="/2019/01/27/笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》/">笔记——《从PAXOS到Zookeeper——分布式一致性原理与实践》</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 SeventyNine<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>