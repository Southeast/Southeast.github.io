<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Life Career</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Life Career">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Life Career">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Life Career">
  
    <link rel="alternate" href="/atom.xml" title="Life Career" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Life Career</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java团队code style规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/java团队code style规范/" class="article-date">
  <time datetime="2018-04-10T01:58:14.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java团队code-style规范"><a href="#java团队code-style规范" class="headerlink" title="java团队code style规范"></a>java团队code style规范</h1><ul>
<li>摘选自《阿里巴巴Java开发手册》（孤尽），主要挑选个人感受最多的，影响代码阅读和维护、易于产生错误或误解的点，期望在团队层面建立良好的、易于接受推进的编码习惯和风格。</li>
<li>总结了少量重要的java知识点错用、误用的场景，需要在日常coding中避免</li>
<li>《阿里巴巴Java开发手册》原文可以在<a href="https://m.aliyun.com/yunqi/articles/215391" target="_blank" rel="external">阿里云</a>下载，也可以购买纸质版（略贵）、</li>
</ul>
<h2 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ul>
<li><font colore="blue">以达到代码自解释为目的</font></li>
<li>常量全部使用大写，单次之间用下划线”_”隔开；非常量及函数使用UpperCamelCase风格</li>
<li>不要嫌明明太长，不合理的缩写产生的影响远比多读几个单次要大</li>
<li>禁止使用拼音英文混合的命名方式，一般也不建议使用全拼音</li>
<li>数组定义统一使用String[] args的格式，不要使用String args[]</li>
<li>POJO类的bool类型变量不加is，防止有些框架解析错误（自动去掉is）</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>拒绝magic value</li>
</ul>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><ul>
<li>long类型赋值，用L结尾，不要用l，容易与1产生混淆。long testValue = 0L；不要用做long testValue = 0l</li>
<li>关于换行<ul>
<li>第二行相对第一行缩进4个空格，第三行开始不再持续缩进</li>
<li>运算符与下文一起缩进。<pre><code><br>boolean testFlag = aVeryLongNameMethodWithBoolReturnValueFoo1()<pre><code>&amp;&amp; anotherVeryLongNameMethodWithBoolReturnValueFoo2()
&amp;&amp; anotherVeryLongNameMethodWithBoolReturnValueFoo3();
</code></pre>  </code></pre></li>
<li>.与下文一起缩进。<pre><code><br>StringBuilder testStringBuilder = new StringBuilder()<pre><code>.append(&quot;test&quot;)
.append(&quot;test1&quot;);
</code></pre></code></pre></li>
</ul>
</li>
<li>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开</li>
</ul>
<h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><ul>
<li>复写方法必须加@Override</li>
<li>开放出去的接口不允许修改或删除接口签名（包括类名、方法名、常量名）</li>
<li>禁止使用@Deprecated方法</li>
<li>Object.equals()，为防止NPE，使用”test”.equals(aStr)替代aStr.equals(“test”)</li>
<li>注意primitive类型比较时，注意auto box和unbox的规则，如不了解，全部是primitive时使用==，涉及包装类对象时，使用equals</li>
<li>POJO属性全部使用包装类对象，RPC方法参数、返回值使用包装类对象</li>
<li>类内部的方法定义顺序：public方法/protected方法 &gt; private方法 &gt; getter/setter</li>
<li>集合初始化时指定集合初始大小</li>
<li>Map遍历使用entrySet，不要使用keySet</li>
</ul>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ul>
<li>多重嵌套的if-else语句使用卫语句代替</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>通过好的命名来达到自解释</li>
<li>类、类属性、类方法注释必须使用Javadoc规范，功能复杂的难以做到self descriptive的需要说明类和方法分别做什么事情，根据需要也应该增加复杂逻辑的解释</li>
<li>所有类都要添加创建者和创建日期</li>
</ul>
<h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><ul>
<li>使用占位符替代字符串拼接，特别注意debug日志，可以防止不必要的字符串拼接<pre><code><br>// 使用<br>log.debug(“processing trade, id={}, name={}”, id, name);<br>// 不使用<br>log.debug(“processing trade, id=” + id + “, name=” + name);<br></code></pre></li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul>
<li>索引命名<ul>
<li>主键 PK_${fieldName}</li>
<li>唯一索引 UK_${fieldName}</li>
<li>普通索引 IDX_${fieldName}</li>
</ul>
</li>
<li>小数类型使用decimal，禁止使用double和float</li>
<li>表必备字段id，gmt_create, gmt_modified</li>
<li>varchar字段建索引时要指定长度，不需要全部索引</li>
<li>不要使用count(1), count(列名)替代count（*）</li>
<li>POJO类bool属性命名不能加is前缀，而数据库字段需加is</li>
<li>更新时指定字段更新，不要传入对象全部更新</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/java团队code style规范/" data-id="cjfv497e20004j4qhdh7yixb0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-旅行行业基础数据本地管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/26/旅行行业基础数据本地管理/" class="article-date">
  <time datetime="2018-03-26T08:06:52.000Z" itemprop="datePublished">2018-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/26/旅行行业基础数据本地管理/">旅行行业基础数据本地管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>旅行行业有许多稳定的、要查询反复使用的数据，如火车票的站点信息、航路信息，酒店的基础信息等。且这些数据往往单体数据较大，在频繁查询过程中要占用大量的网络带宽。</li>
<li>鉴于以上特点，我们考虑把这些数据放到其所在服务之中，不用再通过网络访问，由于数据稳定，使用定期同步（外加手动同步）的方式进行更新</li>
</ul>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>解决核心基础数据就（country,province,city,district,landmark,guide,intro等）的数据单点问题，减少其服务压力(20个系统依赖一个数据服务)</li>
<li>使用服务器上的本地存储，维护旅行行业基础信息，减少不必要的网络带宽占用，提高访问速度</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><ul>
<li>在服务启动时，将数据库中存储的数据加载到内存中，并根据使用需要建立map，查询数据时用相关的key从map中取数据</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code>
    private static volatile Map<integer, hotelbrand=""> _hotelBrandResult = Maps.newHashMap();

    // 数据初始化，注意如果不使用ConcurrentMap，不能并发写数据
    protected boolean handle_DataInit() {
        boolean isSuccess = true;

        try {
            // 计算数据，填充数据
            Map<integer, hotelbrand=""> hotelBrandMap = Maps.newHashMap();
            List<hotelbrand> dataList = hotelBrandDao.queryListAll();
            for (HotelBrand data : dataList) {
                hotelBrandMap.put(data.getBrandID(), data);
            }

            _hotelBrandResult = hotelBrandMap;

            // 设置数据加载成功标识
            _isDataLoaded = true;

        } catch (Throwable ex) {
            isSuccess = false;
            getLogger().error(String.format(LogInfoUtils.HAS_DATA_TMPL, methodName, logData), ex);
        }

        return isSuccess;
    }

    /** ==================== 读取数据部分 ==================== **/
    /**
     * 读取酒店品牌数据
     * 
     * @param brandID
     * @return
     */
    public HotelBrand getHotelBrand(int brandID) {
        //缓存加载完成前查询，需要等待缓存加载完成
        if (checkLocalDataIsLoaded()) {
            if (_hotelBrandResult.containsKey(brandID)) {
                return _hotelBrandResult.get(brandID);
            }
        }

        return null;
    }
</hotelbrand></integer,></integer,></code></pre>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>优点<ul>
<li>现成的对象存储，无需ORMapping</li>
<li>访问速度最快</li>
</ul>
</li>
<li>缺点<ul>
<li>需要在服务启动时初始化，拖累启动速度；</li>
<li>只能KV存储，同一份数据，如果需要多个key，就需要建立多个map</li>
<li>如不阻塞服务，在服务上线时缓存可能仍未加载完成，导致服务长时间阻塞</li>
<li>当数据增长到一定规模，服务启动时间会长到无法接受</li>
</ul>
</li>
</ul>
<h2 id="BerkeleyDB"><a href="#BerkeleyDB" class="headerlink" title="BerkeleyDB"></a>BerkeleyDB</h2><h3 id="bdb简介"><a href="#bdb简介" class="headerlink" title="bdb简介"></a>bdb简介</h3><ul>
<li>设计思想：简单、小巧、可靠、高性能</li>
<li>kv存储，支持k-List<v>存储，支持secondary key，不支持sql，不需要sql编译解析</v></li>
<li>支持1000并发，最大256T存储</li>
<li>嵌入式数据库，不支持网络访问，与应用程序运行在一个地址空间，不需要进程间通信</li>
<li><a href="https://www.cnblogs.com/chenny7/p/4864547.html" target="_blank" rel="external">bdb架构设计分析</a></li>
<li>我们使用bdb java edition，<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html" target="_blank" rel="external">使用文档</a></li>
</ul>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul>
<li>从基础数据源（一般是mysql或分库分表的mysql）</li>
<li>数据存储与访问</li>
<li>数据更新策略<ul>
<li>增量模式，通过数据时间戳（不支持物理删除）或数据库binlog</li>
<li>全量重新构建（时间较长，只在服务启动时检查）</li>
</ul>
</li>
<li>从PrimaryIndex可以进行K-V读取</li>
<li>从SubIndex可以进行</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>多个服务不能同时使用同一个数据库文件</li>
<li>注意cursor打开后需要手动关闭</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><ul>
<li>bdb java edition的DPL API可以方便的使用注解实现</li>
<li><p>数据对象,通过Persistent（在基类中使用）和Entity标示bdb的数具实体，@PrimaryKey和@SecondaryKey分别标示主键和外键。通常主键是1对1的（k-v），外键可以指定1对1，1对多，多对1，多对多等不同关系<pre><code><br>@Entity<br>@Getter@Setter<br>@ToString<br>public class HotelBasic extends HotelBase implements Serializable {</code></pre></p>
<p>  /**</p>
<ul>
<li><p>酒店类型枚举<br>*/<br>private HotelTypeEnum hotelType;</p>
<p>/**</p>
</li>
<li><p>酒店名称<br>*/<br>private String name = “”;</p>
<p>/**</p>
</li>
<li><p>酒店英文名称<br>*/<br>private String enName = “”;</p>
<p>/**</p>
</li>
<li>酒店地址<br>*/<br>private String address = “”;</li>
</ul>
</li>
</ul>
<p>}</p>
<p>@Persistent<br>@Getter@Setter<br>@ToString<br>public class HotelBase implements Serializable {<br>    private static final long serialVersionUID = 3692698826181676533L;</p>
<pre><code>/** =============== field =============== */
/**
 * hotelID
 */
@PrimaryKey
private int hotelID;

/**
 * 国家ID
 */
private int countryID;

/**
 * cityID
 */
@SecondaryKey(relate = MANY_TO_ONE)
private int cityID;

/**
 * 酒店级别
 */
private HotelSeriesEnum hotelSeries = HotelSeriesEnum.ECONOMY;
</code></pre><p>}</p>
<p></p>
<ul>
<li><p>数据操作</p>
<ul>
<li>依赖方引入包依赖，并加入服务开机启动配置（如servlet）。如果需要默认启用该缓存，也可以直接实现InitializingBean，但是因为数据量较大，且不同系统的依赖不同，因此都没有直接做默认启用。</li>
<li>同一个数据库文件不能被多服务并发访问。如果单机部署不同服务，可以配置环境变量来建立多个DbEnvironment。如HOTEL_BDB_DATA_DIRECTORY = new File(“/opt/bdb/$projectName/hotel/hotelbasic”)</li>
<li><p><pre><code><br>/**</code></pre></p>
<ul>
<li>Created by tomxiaodong on 17/4/6.<br>*/<br>@Slf4j<br>@Component<br>public class HotelBasic_BdbProxy extends HotelBdbProxyBase {</li>
</ul>
<p>private static File HOTEL_BDB_DATA_DIRECTORY;<br>private static EnvironmentConfig envConfig = (EnvironmentConfig) new EnvironmentConfig().setAllowCreate(true).setCacheSize(100<em>1024</em>1024);<br>private static StoreConfig storeConfig = new StoreConfig().setAllowCreate(true);<br>private Environment env;</p>
<p>static {<br>  HOTEL_BDB_DATA_DIRECTORY = new File(“/opt/bdb/hotel/hotelbasic”);</p>
<p>  if(!HOTEL_BDB_DATA_DIRECTORY.exists()) {</p>
<pre><code>HOTEL_BDB_DATA_DIRECTORY.mkdirs();
</code></pre><p>  }<br>}</p>
<p>private EntityStore hotelBasicStore;<br>private PrimaryIndex<integer, hotelbasic=""> pIdx;<br>private SecondaryIndex<integer, integer,="" hotelbasic=""> sIdx;</integer,></integer,></p>
<p>private final ExecutorService _dataInitExecutorPool = Executors.newCachedThreadPool();</p>
</li>
</ul>
</li>
</ul>
<pre><code>private Random rand = new Random();

@Resource
private BdbUpdateTime_BdbProxy bdbUpdateTime_BdbProxy;

@Resource
private SysCityDao sysCityDao;

@Resource
private HotelBasic_CacheProxy hotelBasic_CacheProxy;

@Resource
private HotelComment_CacheProxy hotelComment_CacheProxy;

/**
 * 读取某城市下的 HotelBasic 列表（全部）
 *
 * @param cityID
 * @return
 */

public List&lt;HotelBasic&gt; getHotelBasicList(int cityID) {
    List&lt;HotelBasic&gt; result = Lists.newArrayList();
    EntityCursor&lt;HotelBasic&gt; cursor = sIdx.subIndex(cityID).entities();
    cursor.forEach(x -&gt; result.add(x));
    cursor.close();
    return result;
}

/**
 * 读取某城市下的 HotelBasic 列表（每个酒店的评论必须大于minCommentCount，并且评分&gt;0）
 *
 * @param cityID
 * @param minCommentCount
 * @return
 */
public List&lt;HotelBasic&gt; getHotelBasicListHasComment(int cityID, int minCommentCount) {

    long now = System.currentTimeMillis();
    List&lt;HotelBasic&gt; result = Lists.newArrayList();

    List&lt;HotelBasic&gt; hotelBasics = getHotelBasicList(cityID);
    for (HotelBasic hotelBasic : hotelBasics) {
        if (hotelBasic.getCommentCount() &gt; minCommentCount &amp;&amp; hotelBasic.getScore() &gt; 0) {
            result.add(hotelBasic);
        }
    }
    return result;
}

/**
 * 读取 HotelBasic 对象
 *
 * @param hotelID
 * @return
 */
public HotelBasic getHotelBasic(int hotelID) {
    return pIdx.get(hotelID);
}

private void putHotelBasic(HotelBasic hotelBasic){
    pIdx.put(hotelBasic);
}

@Override
/**
* 从源数据同步
*/
public void syncData(boolean replace){
    long startTimeMillis = System.currentTimeMillis();
    Date lastUpdateTime = bdbUpdateTime_BdbProxy.getLastUpdateTime(getClass().getSimpleName());
    if(lastUpdateTime!=null){
        LocalDateTime ldt = LocalDateTime.ofEpochSecond(lastUpdateTime.getTime()/1000, 0, ZoneOffset.UTC);
        if(ldt.plusHours(getRefreshInterval()).isAfter(LocalDateTime.now())) {
            log.warn(&quot;sync hotelbasic bdb skipped!&quot;);
            return;
        }
    }

    try {
        Map&lt;Integer, List&lt;HotelBasic&gt;&gt; hotelBasicsMap = Maps.newHashMap();
        int total = 0;

        // 计算自由行目的城市ID列表
        //List&lt;Integer&gt; arrCityIDs = (!DebugConfigUtils.isDebug()) ? sysCityDao.querySolutionArrCityIDs() : new DebugCityConfigDaoProtoImpl().getDebugToCityIDs();
        List&lt;Integer&gt; arrCityIDs =sysCityDao.querySolutionArrCityIDs();

        // 多线程分批读取缓存数据
        List&lt;List&lt;Integer&gt;&gt; arrCityIDsList = CustomListMathUtils.splitToListsByListItemCount(arrCityIDs, 10);
        for (List&lt;Integer&gt; cityIDs : arrCityIDsList) {
            List&lt;Callable&lt;List&lt;HotelBasic&gt;&gt;&gt; tasks = Lists.newArrayList();
            for (final int cityID : cityIDs) {
                tasks.add(() -&gt; hotelBasic_CacheProxy.getCityHotelBasicList(cityID));
            }

            // 执行 Callable 线程，取得结果
            List&lt;Future&lt;List&lt;HotelBasic&gt;&gt;&gt; futures = _dataInitExecutorPool.invokeAll(tasks);
            for (Future&lt;List&lt;HotelBasic&gt;&gt; future : futures) {
                List&lt;HotelBasic&gt; hotelBasics = future.get();
                if(hotelBasics.size()&gt;0){
                    hotelBasicsMap.put(hotelBasics.get(0).getCityID(), hotelBasics);
                    total+=hotelBasics.size();
                }
            }
        }

        // 多线程分批读取酒店评论数
        int hasCommentCount = 0;
        for (Map.Entry&lt;Integer, List&lt;HotelBasic&gt;&gt; entry : hotelBasicsMap.entrySet()) {
            Map&lt;Integer, Integer&gt; hotelListCommentCountMap = getHotelListCommentCountMap(entry.getValue());

            for (HotelBasic hotelBasic : entry.getValue()) {
                if (hotelListCommentCountMap.containsKey(hotelBasic.getHotelID())) {
                    hasCommentCount++;
                    hotelBasic.setCommentCount(hotelListCommentCountMap.get(hotelBasic.getHotelID()));
                    putHotelBasic(hotelBasic);
                }
            }
        }

        bdbUpdateTime_BdbProxy.setLastUpdateTime(getClass().getSimpleName());

        log.warn(&quot;sync hotelbasic bdb success! totalCount:{}, hasCommentCount:{}, time consumed:{}&quot;, total, hasCommentCount, System.currentTimeMillis()-startTimeMillis);
    } catch (Throwable ex) {
        log.error(&quot;sync hotelbasic bdb failed!&quot;, ex);
    }

}

public long count(){
    return pIdx.count();
}

@Override
public long getRefreshInterval() {
    return 24*150;
}

@Override
public TimeUnit getIntervalTimeUnit() {
    return TimeUnit.HOURS;
}

/**
 * 多线程分批读取酒店评论数
 *
 * @param hotelBasics
 * @return
 */
private Map&lt;Integer, Integer&gt; getHotelListCommentCountMap(List&lt;HotelBasic&gt; hotelBasics) {
    Map&lt;Integer, Integer&gt; result = Maps.newHashMap();

    try {
        List&lt;Integer&gt; allHotelIDs = hotelBasics.stream().map(x -&gt; x.getHotelID()).collect(Collectors.toList());
        List&lt;List&lt;Integer&gt;&gt; hotelIDsList = CustomListMathUtils.splitToListsByListCount(allHotelIDs, PagingUtils.calPageCount(allHotelIDs.size(), 50));

        // 分批读取酒店评论数
        for (final List&lt;Integer&gt; hotelIDs : hotelIDsList) {
            List&lt;Callable&lt;KeyValuePair&lt;Integer, Integer&gt;&gt;&gt; tasks = Lists.newArrayList();
            for (final int hotelID : hotelIDs) {
                tasks.add(() -&gt; new KeyValuePair(hotelID, hotelComment_CacheProxy.getHotelCommentCount_All(hotelID)));
            }

            // 执行 Callable 线程，取得结果
            List&lt;Future&lt;KeyValuePair&lt;Integer, Integer&gt;&gt;&gt; futures = _dataInitExecutorPool.invokeAll(tasks);
            for (Future&lt;KeyValuePair&lt;Integer, Integer&gt;&gt; future : futures) {
                KeyValuePair&lt;Integer, Integer&gt; kv = future.get();
                result.put(kv.getKey(), kv.getValue());
            }
        }
    } catch (Throwable ex) {
        log.error(&quot;getHotelListCommentCountMap failed!&quot;, ex);
    }

    return result;
}

public PrimaryIndex&lt;Integer, HotelBasic&gt; getpIdx() {
    return pIdx;
}

public void close(){
    if(hotelBasicStore!=null){
        hotelBasicStore.close();
        hotelBasicStore = null;
    }
    if(env!=null) {
        env.close();
        env = null;
    }
}

public void init(){
    env = new Environment(HOTEL_BDB_DATA_DIRECTORY, envConfig);
    hotelBasicStore = new EntityStore(env, &quot;hotelBasic&quot;, storeConfig);
    pIdx = hotelBasicStore.getPrimaryIndex(Integer.class, HotelBasic.class);
    sIdx = hotelBasicStore.getSecondaryIndex(pIdx, Integer.class, &quot;cityID&quot;);
}
</code></pre><p>}<br></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>百万数据量，100M bdb缓存，K-V访问平均小于1ms，K-List<v>访问在1-5ms之间，峰值qps&gt;500</v></li>
<li>收集一组日志，通过ELK做图</li>
</ul>
<h1 id="深入BerkeleyDB"><a href="#深入BerkeleyDB" class="headerlink" title="深入BerkeleyDB"></a>深入BerkeleyDB</h1><ul>
<li>并发支持</li>
<li>cache</li>
<li>index<ul>
<li>secondary key</li>
<li>secondary database</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/26/旅行行业基础数据本地管理/" data-id="cjfv497eg000dj4qhxbyqvou0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="shellcommands-shell-commands-case-study" class="article article-type-shellcommands" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/21/shell-commands-case-study/" class="article-date">
  <time datetime="2018-03-21T03:12:35.000Z" itemprop="datePublished">2018-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/shell-commands-case-study/">shell commands case study</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="高频shell命令及使用场景总结"><a href="#高频shell命令及使用场景总结" class="headerlink" title="高频shell命令及使用场景总结"></a>高频shell命令及使用场景总结</h1><ul>
<li><font color="blue">本文的目的是通过列举一些高频命令的常见使用场景，帮助后端开发或ops快速铺平道路，因此很多命令都只有很基础的使用方式，更多更深入的用法请使用man命令来阅读详尽的使用说明</font></li>
<li>不必因为自己会的命令不如别人多或不如别人熟练而沮丧，使自己能够高效的围绕linux平台工作学习才是最终的目的，只要通过持续的学习和使用就一定能很快达到</li>
</ul>
<h2 id="磁盘与文件"><a href="#磁盘与文件" class="headerlink" title="磁盘与文件"></a>磁盘与文件</h2><h3 id="基础磁盘文件操作"><a href="#基础磁盘文件操作" class="headerlink" title="基础磁盘文件操作"></a>基础磁盘文件操作</h3><ul>
<li>cp 使用-r选项来复制目录 cp -r a/b a1/b1</li>
<li>mkdir 使用-p选项创建嵌套的目录 mkdir -p a/b/c/d</li>
<li>rm -rf 强制静默删除，虽然看起来挺危险的，但是这确实是我最常使用的方式</li>
<li>mv 用来移动或重命名 mv a b</li>
<li>ls list directory，文件不多的时候一般我都使用ls -al以便一次性看到全部文件和必要的时间、大小等属性。可以创建一个别名alias ll = ‘ls -al’来更方便的使用</li>
<li>chmod 给指定文件增减权限 chmod o+x给文件增加可执行权限，写shell时肯定要用到</li>
<li>chown 改变文件owner， 有时候使用了错误的用户执行创建/复制/下载/安装等操作，会希望改变文件的owner</li>
</ul>
<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><ul>
<li>find    <ul>
<li>按名称 -name，如查找当前目录以test加任意三个字符结尾的文件或文件夹find . -name “*test???” </li>
<li>按类型 -type，如查找当前目录所有文件：find . -type f</li>
<li>通过-exec来<font color="blue">批量操作</font><ul>
<li>find . -maxdepth 1 -name “*test” -exec rm -rf {} \;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul>
<li>复制远程目录到本地 scp -r root@10.0.0.1:/home/admin/test/ ./</li>
<li>复制本地文件到远程 scp ./test root@10.0.0.1:/home/admin/test/</li>
</ul>
<h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><h3 id="vi文件编辑"><a href="#vi文件编辑" class="headerlink" title="vi文件编辑"></a>vi文件编辑</h3><ul>
<li>vi<ul>
<li>上下左右j k l ;</li>
<li>f下一行 b上一行 Ctrl+f下一页 Ctrl+b上一页</li>
<li>查找 /</li>
<li>替换 :s替换当前行，:%s替换全文，可使用正则表达式</li>
<li>常用正则表达式（只按场景举例，基础规则可以参考<a href="http://qianjigui.iteye.com/blog/368449" target="_blank" rel="external">这里</a>）,学会用[a-zA-Z0-9]{m,n}的语法可以解决很多问题<ul>
<li>简化的ip地址[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符串查找与替换"><a href="#字符串查找与替换" class="headerlink" title="字符串查找与替换"></a>字符串查找与替换</h3><ul>
<li>grep 查找行。<font color="red">grep、awk、sed号称linux命令三剑客，如果你常年在服务端环境工作，或者你使用基于linux的开发环境（mac、ubuntu等），有必要熟练掌握这3个命令和基本的正则表达式，尽早舍弃那些低效的GUI吧！</font><ul>
<li>一般查找 grep “content” file</li>
<li>忽略大小写 grep -i “ConTEnt” file</li>
<li>反选（查找不包含指定内容的行） grep “inclusiveContent” file | grep -v “exclusiveContent” </li>
</ul>
</li>
<li>sed(stream editor for filtering and transforming text). 如果你经常使用vi，可以把这个命令理解为批量执行的vi命令。如果你man sed头痛的话，可以参考<a href="http://man.linuxde.net/sed" target="_blank" rel="external">这篇文章</a>其中有很多例子<ul>
<li>替换文件中的内容，类似vi中的:s和:%s。 sed -i “bak” ‘s/originContent/newContent/g’, 注意mac中必须指定 -i选项的备份文件后缀（如上述命令中的bak，自信的人可以直接使用空字符串””）</li>
<li>删除空白行，sed -i “bak” ‘/^$/d’ fileName</li>
<li>在第9行插入标记，sed -i “bak” ‘9a/tag’ fileName</li>
</ul>
</li>
</ul>
<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><ul>
<li>awk类似sed，通常也是逐行接收文件内容，执行命令处理文本。不同的是，awk定义了自己的语言，叫做“样式扫描和处理语言”，通过创建剪短的程序读取文件、对数据进行排序、计算、生成报表等操作。使用方式为 awk ‘{pattern + action}’ {filenames}<ul>
<li>杀死某个关键字对应的进程 ps aux | grep tomcat | awk ‘{print $2}’ | xargs kill -9</li>
</ul>
</li>
<li>shell parameter expansion。把变量放入${}中，并指定一些特定的操作符，实现对变量的操作，通过这种方式，可以很便捷的对变量做很多常用的操作（比awk代码更简洁易上手，虽然功能没有awk多）<ul>
<li>如${parameter:7}返回截取字符串或数组第7位以后（不包括第7位）的子串或子集</li>
<li>${ #parameter}返回parameter的长度</li>
<li>${parameter##<em>:}返回左数最后一个:右边的内容，类似的${parameter#</em>:}返回的是左数第一个:右边的内容、${parameter%%:<em>}返回右数最后一个:左边的内容，${parameter%:</em>}返回右数第一个:左边的内容。这在文件名处理、行数据处理（如不同分隔符分隔的数据库记录）等很有用，特别是如果你的正则表达式也跟我一样二把刀，不想每次现用现查的话</li>
<li>IFS=’:’; arr=($line)可以把line数据按分隔符拆分并组织成数组，类似java中是String.split(“:”)。使用echo ${arr[0]}打印数组的第1个元素</li>
</ul>
</li>
</ul>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="ssh用于登陆远程linux服务器"><a href="#ssh用于登陆远程linux服务器" class="headerlink" title="ssh用于登陆远程linux服务器"></a>ssh用于登陆远程linux服务器</h3><ul>
<li>使用其他的linux终端（我使用的是iterm）来登陆远程linux服务器，可以像在本地终端一样使用各种命令操作远程服务器</li>
<li>通过将本地公钥复制到远程服务器的~/.ssh/authorized_keys文件实现免密登陆。</li>
<li>公钥的生成使用ssh-keygen -t rsa，密码可以设置为空，生成的公钥位于~/.ssh/id_rsa.pub</li>
<li>可以通过ssh，在脚本中批量登陆服务器执行命令。如你想一次性为多个服务器复制公钥，全部实现上述的免密登陆<pre><code><br>cat $fileName | while read line<br>do<br>  echo $line<br>  #在远程服务器创建.ssh目录<br>  ssh -n root@$line “mkdir -p /root/.ssh &amp;&amp; touch /root/.ssh/authorized_keys”<br>  #复制key到远程服务器<br>  ssh root@$line  “cat &gt;&gt; /root/.ssh/authorized_keys” &lt; ~/.ssh/id_rsa.pub<br>done<br></code></pre></li>
<li>-n选项可以防止标准输入打断批量脚本执行</li>
</ul>
<h3 id="top-amp-free"><a href="#top-amp-free" class="headerlink" title="top &amp; free"></a>top &amp; free</h3><ul>
<li>top。查看当前系统状态、各进程的资源（cpu、内存、load等）占用情况，想详细了解各行各列内容可以参考这篇<a href="https://www.cnblogs.com/dragonsuc/p/5512797.html" target="_blank" rel="external">文章</a><ul>
<li>打开top后，输入M按内存顺序排列进程，查看占用内存最多的进程 </li>
<li>P按cpu占用排序</li>
<li>多核状态下，默认显示的是所有cpu平均值，输入1查看多核各cpu的状态</li>
<li>top -Hp <pid>可以查看指定进程的所有线程的状态</pid></li>
</ul>
</li>
<li>free。top中显示的内存包含了buffer/cache占用，系统一般都会尽量多的占用内存以提升响应速度，所以可以用free命令来查看实际使用中的内存情况。<ul>
<li>free -m</li>
<li>考虑JVM占用内存时不能只考虑堆大小，堆大小可能只占整个虚拟机的40%，以一个2G大小堆的java进程为例，通常要预留2G（2M*1000线程）的栈内存，1G的Meta和其它内容。这意味着你要在系统中为java进程预留大约5G的内存</li>
</ul>
</li>
</ul>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><ul>
<li>查看所有进程并按进程号过滤 ps -ef | grep <pid></pid></li>
<li>同上述命令类似，不过这个命令使用的是bsd格式来展示进程信息，并按关键字过滤，关键字可以是tomcat、项目名称等 ps aux | grep <keyword></keyword></li>
</ul>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><ul>
<li>遇到端口被占用情况时可以用netstat -ap查看所有连接的端口和进程号，从而找到未正确退出或重复启动，导致新进程不能启动的进程。 netstat -ap | grep <port></port></li>
</ul>
<h3 id="var-logs-message"><a href="#var-logs-message" class="headerlink" title="/var/logs/message"></a>/var/logs/message</h3><ul>
<li>记录了一些系统级别的记录，比如目前我们遇到的最常见的是oomkill记录，由于服务压力较大，有时候会遇到物理内存耗尽，系统杀死内存大户的情况。如果你遇到一些奇怪的系统问题，比如进程莫名其妙没了，也没有留下退出日志(hs<em>err</em><pid>)，可以在这里查看</pid></li>
</ul>
<h3 id="var-logs-security"><a href="#var-logs-security" class="headerlink" title="/var/logs/security"></a>/var/logs/security</h3><ul>
<li>这个日志记录了一些安全方面的信息，可以查看是否有被暴力ssh登陆；有时候我们的ip被denyhosts误伤，可以在这里查到日志（当然也可以直接在denyhosts中查看）。<h3 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h3></li>
<li>keygen用来为系统用户生成密钥对，在ssh免密登陆和git访问等场景经常需要<ul>
<li>ssh-keygen -t rsa</li>
</ul>
</li>
</ul>
<h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><h3 id="du-amp-df"><a href="#du-amp-df" class="headerlink" title="du&amp;df"></a>du&amp;df</h3><ul>
<li>怀疑磁盘空间不足时，使用df查看</li>
<li>用du确定当前目录的磁盘占用情况<ul>
<li>用du -m以MegaByte为单位显示占用量</li>
<li>如果文件太多，可以用du –max-depth=1只显示当前目录（不递归查看子目录）</li>
</ul>
</li>
</ul>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><ul>
<li>获取网页内容curl <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></li>
<li>下载文件。curl -O www.xxx.com/download/aaa.zip</li>
</ul>
<h1 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h1><h2 id="2017-06-13-load过高问题"><a href="#2017-06-13-load过高问题" class="headerlink" title="2017.06.13 load过高问题"></a>2017.06.13 load过高问题</h2><ul>
<li>热点代码定位 参考<a href="http://javaeesupportpatterns.blogspot.ca/2012/02/prstat-linux-how-to-pinpoint-high-cpu.html" target="_blank" rel="external">这里</a><ol>
<li>使用jstack <pid> &gt; /tmp/a dump线程到文件备查</pid></li>
<li>使用top -Hp <pid> 查看占用cpu最高的线程</pid></li>
<li>将2中linux线程id转为16进制，在1中文件查找，找到对应线程</li>
<li>如果是线程池pool-1-thread-1形式的线程，通常在栈信息中无法定位到具体的业务代码，你需要先把系统所有线程池自定义名称。如ExecutorService executor = Executors.newXXXExecutor(r -&gt; new Thread(r, “arbitrary-pool-thread-“))</li>
<li>找到有问题的代码，优化相关代码</li>
</ol>
</li>
<li>相关工具<ul>
<li>jstack <pid></pid></li>
<li>top -Hp <pid></pid></li>
<li>greys，在线诊断，类似btrace，但是使用更轻量（无需编写代码）。可以在线查看方法执行时间、追踪方法的每一步执行时间、方法调用次数和参数返回值等，非常强大。<a href="https://github.com/oldmanpushcart/greys-anatomy" target="_blank" rel="external">https://github.com/oldmanpushcart/greys-anatomy</a></li>
</ul>
</li>
</ul>
<h2 id="2017-07-12-load过高、内存泄漏问题"><a href="#2017-07-12-load过高、内存泄漏问题" class="headerlink" title="2017.07.12 load过高、内存泄漏问题"></a>2017.07.12 load过高、内存泄漏问题</h2><ol>
<li>热点代码定位同上，确认是VM线程gc overhead占用cpu，判断是内存已满</li>
<li>jstack -gcold <pid> 确认堆已满，一直fullgc且没有腾出内存</pid></li>
<li>jmap -histo <pid> 下载内存镜像</pid></li>
<li>使用mat查看对象最多的类型，定位问题</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/21/shell-commands-case-study/" data-id="cjfv497ea0008j4qhkyde1vwu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell-linux-ops/">shell,linux,ops</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-servermonitoring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/15/servermonitoring/" class="article-date">
  <time datetime="2017-07-15T04:52:58.000Z" itemprop="datePublished">2017-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>目标</li>
<li>原理</li>
<li>方案选择<ul>
<li>商业方案：本地oneAPM(本地化服务)，国际NETWAYS（便宜，价钱一半）</li>
</ul>
</li>
</ul>
<h2 id="icinga介绍"><a href="#icinga介绍" class="headerlink" title="icinga介绍"></a>icinga介绍</h2><ul>
<li>简介</li>
<li>核心概念</li>
<li>模型</li>
</ul>
<h2 id="icinga实践"><a href="#icinga实践" class="headerlink" title="icinga实践"></a>icinga实践</h2><h3 id="服务监控搭建"><a href="#服务监控搭建" class="headerlink" title="服务监控搭建"></a>服务监控搭建</h3><h3 id="监控集群设计方案"><a href="#监控集群设计方案" class="headerlink" title="监控集群设计方案"></a>监控集群设计方案</h3><ul>
<li>监控报警</li>
<li>报表接入</li>
<li>配置方案选择：底层文件配置 or 可视化配置 Icinga Director</li>
<li>主机监控<ul>
<li>ping</li>
<li>ssh -p</li>
</ul>
</li>
<li>redis监控</li>
<li>ssdb监控</li>
<li>mysql监控</li>
</ul>
<h3 id="master机器迁移"><a href="#master机器迁移" class="headerlink" title="master机器迁移"></a>master机器迁移</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1000个基于perl脚本命令的service导致high-load问题"><a href="#1000个基于perl脚本命令的service导致high-load问题" class="headerlink" title="1000个基于perl脚本命令的service导致high load问题"></a>1000个基于perl脚本命令的service导致high load问题</h3><p>### </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/15/servermonitoring/" data-id="cjfv497e60005j4qhc0ngqx7l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/27/操作系统/" class="article-date">
  <time datetime="2017-04-27T06:08:59.000Z" itemprop="datePublished">2017-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>CPU核心概念<ul>
<li>中断</li>
<li>寄存器</li>
<li>CPU MODE：内核态、用户态</li>
</ul>
</li>
<li>实时操作系统<ul>
<li>CPU时间片算法：</li>
<li>抢占/非抢占</li>
<li>Timer</li>
</ul>
</li>
<li>OS核心功能组件<ul>
<li>内存管理</li>
<li>I/O管理</li>
<li>GPU</li>
<li>网络</li>
<li>多媒体</li>
</ul>
</li>
</ul>
<h3 id="RTOS-design"><a href="#RTOS-design" class="headerlink" title="RTOS design"></a>RTOS design</h3><ul>
<li><font color="blue">根据已有的CPU文档（ARM Quad A7 core）、主板文档（BCM2835 ARM peripherals），对底层硬件进行操作，包括寄存器、内存、GPU等</font></li>
<li>封装底层硬件、为上层应用提供API，可以查阅<font color="red">Linux Kernel</font>的lib，你们要求application跨平台，可以查阅<font color="red">Java JVM的跨平台设计</font></li>
<li>realtime的关键应该是抢占式调度，需要基于中断实现</li>
<li>四核CPU，要实现多核并发，主要是协调四个CPU同时工作。比如给4个CPU各分配一个任务，任务完成后怎么通知其它CPU，并协调下一步指令执行。应该是<font color="red">基于cpu的mailbox去实现</font>，关注一下QA7文档的mailbox部分。另外就是查一下线程/进程的状态转换模型和调度模型</li>
<li>内存寻址要搞清楚虚拟地址和物理地址之间的转换，再看一下文档的Memory Manage Unit(MMU)和Direct Memory Access（DMA）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/27/操作系统/" data-id="cjfv497ee000bj4qheil6gabw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式服务监控 - 概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/分布式服务监控 - 概述/" class="article-date">
  <time datetime="2017-03-23T06:58:10.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式服务监控-概述"><a href="#分布式服务监控-概述" class="headerlink" title="分布式服务监控 - 概述"></a>分布式服务监控 - 概述</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>目标</li>
<li>概述</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>收集并存储一定时期内的服务器系统状态、网络状态、核心组件的核心指标，常见服务（mysql、redis等）的服务指标</li>
<li>7*24小时对上述指标进行<font color="blue">监控报警</font>，对超过指定阈值的可疑指标发出报警（邮件或短信通知）。区别于dapper和pinpoint的分布式全局调用追踪</li>
<li>对上述指标数据提供<font color="blue">数据报表</font>功能，便于全面的跟踪查看系统的运行状态</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><i>Application Performance Management(应用性能管理，简称APM)</i>：In the fields of information technology and systems management, application performance management is the <font color="blue">monitoring and management of performance and availability of software applications</font>. APM strives to detect and diagnose complex application performance problems to maintain an expected level of service.</li>
<li><font color="blue">商用软件</font>，目前市面上有不少商用的APM管理软件，如<a href="http://www.toushibao.com/" target="_blank" rel="external">oneAPM</a>、<a href="">透视宝</a>等。在监控的目标机器上安装agent，通过agent采集数据推送到服务商的server端，server端提供数据报表展示和监控报警功能。使用这些服务，可以快速的搭建起自己的主机和服务监控，只需要安装相应的agent，并配置相关服务的配置文件如redis、mysql等，主机本身disk、memory、cpu、traffic等指标通常默认支持，不需额外配置；缺点是价格不低，一般要几十块钱每主机每月。</li>
<li><font color="blue">开源软件</font>，我们的集群规模大约在100台左右，一年的价格算下来就在4万块左右，从节约成本的角度我们选择了开源的技术方案。另外作为一个合格的技术人员，一定要有创造一切的雄心！比较常用的开源监控软件有Nagios、Icinga、Zabbix，比较如下，还有更多其它方案可以参考这篇<a href="https://www.serverdensity.com/monitor/linux/how-to/" target="_blank" rel="external">文章</a>，以及serverfalut这篇<a href="http://serverfault.com/questions/44/what-tool-do-you-use-to-monitor-your-servers" target="_blank" rel="external">帖子</a><ul>
<li><a href="http://www.zabbix.com/" target="_blank" rel="external">Zabbix</a>：自带报表更能，安装简单</li>
<li><a href="https://www.nagios.org/" target="_blank" rel="external">Nagios</a>: 使用最广泛，支持所有平台、扩展性好，<font color="red">部署相对复杂</font>、图表需要插件扩展支持</li>
<li><a href="">Icinga2</a>: nagios的fork，是为了解决nagios的更新慢、反馈慢等问题而设立的项目。覆盖Nagios所有功能，更新快、社区活跃</li>
</ul>
</li>
<li>我们最终选用的方案是icinga，考虑的因素包括：nagios的使用广泛、icinga社区的活跃度非常高、以及icinga的分布式支持</li>
<li>icingaweb2监控示意图，<font color="red">通过这些页面可以全面的掌握集群机器和服务的动态</font><ul>
<li>首页：首页显示菜单及当前服务器和服务存在的主要问题（Service Problems)，所有的问题都会以红色警报提示 <img src="https://code.aliyun.com/jindouyuncode/jdy-solution-master/uploads/2fde37d8db8c7cd5bab1009a0e2cfb87/image.png" alt="image"></li>
<li>hosts: hosts菜单显示所有服务器状态<img src="https://code.aliyun.com/jindouyuncode/jdy-solution-master/uploads/e6b93b170310e44fab86a6ea88fee96d/image.png" alt="image"></li>
<li>hostgroups：hostgroups按分组管理所有的服务器 <img src="https://code.aliyun.com/jindouyuncode/jdy-solution-master/uploads/70c0f97ecb898bea9bbd0a3d82709ee2/image.png" alt="image"></li>
<li>servicegroups：按分组管理所有的服务<img src="https://code.aliyun.com/jindouyuncode/jdy-solution-master/uploads/cdbd4f1daf0ac4680b8b241b3022f2eb/image.png" alt="image"></li>
</ul>
</li>
</ul>
<h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li>Master</li>
<li>Satelite</li>
<li>Client</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>features<ul>
<li>通过icinga command line interface命令控制feature，管理通知（notification）、命令（command）、ido-mysql等</li>
<li><img src="https://code.aliyun.com/jindouyuncode/jdy-solution-master/uploads/65a5420a9c21575e17679f1071163cc0/image.png" alt="image"></li>
</ul>
</li>
<li>Template</li>
<li>Command（icinga监控命令） <ul>
<li>Check Commands</li>
<li>示例：<pre><code><br>object CheckCommand “check_redis” {<br> command = [ PluginDir + “/check_redis.pl”]<br> arguments = {<br>   “-H” = “$redis_host$”<br>   “-p” = “$redis_port$”<br>   “-x” = “$redis_pwd$”<br>   “-a” = “mem_fragmentation_ratio,connected_clients,keyspace_hits,used_memory_rss,total_connections_received,blocked_clients”<br>   “-w” = “~,100,~,300M,~,~”<br>   “-c” = “1.0:20,300,~,500M,~,~”<br> }<br>}<br></code></pre></li>
<li>Notification Commands</li>
<li>Event Commands</li>
</ul>
</li>
<li>Service配置<pre><code><br>  apply Service “check-cache-redis” {<pre><code>import &quot;generic-service&quot;
check_command = &quot;check_redis&quot;
vars.redis_host = host.address
vars.redis_port = &quot;7136&quot;
vars.redis_pwd = &quot;j^dy@&quot;
assign where host.name == &quot;icinga-cache1.jindouyun.com&quot;
</code></pre>  }<br>  </code></pre></li>
<li>groups配置，使用apply rules表达式（Apply Rules Expression)批量指定group<pre><code><br>  //服务器分组<br>  object HostGroup “cache-servers” {<pre><code>display_name = &quot;Cache Servers&quot;
assign where match(&quot;*cache*&quot;, host.name)
</code></pre>  }<br>  //服务分组<br>  object ServiceGroup “redis” {<pre><code>display_name = &quot;Redis Checks&quot;
assign where match(&quot;check_redis&quot;, service.check_command)
</code></pre>  }<br>  </code></pre></li>
</ul>
<h2 id="icinga实践"><a href="#icinga实践" class="headerlink" title="icinga实践"></a>icinga实践</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul>
<li>分布式</li>
<li>插件扩展</li>
<li>安全性</li>
</ul>
<h3 id="master安装"><a href="#master安装" class="headerlink" title="master安装"></a>master安装</h3><ul>
<li>安装icinga2<ul>
<li>yum install -y <a href="https://packages.icinga.com/epel/7/release/noarch/icinga-rpm-release-7-1.el7.centos.noarch.rpm" target="_blank" rel="external">https://packages.icinga.com/epel/7/release/noarch/icinga-rpm-release-7-1.el7.centos.noarch.rpm</a></li>
<li>yum install -y icinga2</li>
<li>chkconfig icinga2 on</li>
<li>service icinga2 start</li>
</ul>
</li>
<li>安装httpd<ul>
<li>yum install -y httpd</li>
<li>chkconfig httpd on</li>
<li>service httpd start</li>
</ul>
</li>
<li>安装nagios插件<ul>
<li>yum install -y nagios-plugins-all</li>
</ul>
</li>
<li>安装、初始化mysql库<ul>
<li>DB IDO（DataBase Icinga Data Output）</li>
<li>安装mysql：yum install -y mysql-server mysql &amp;&amp; chkconfig mysqld on &amp;&amp; service mysqld start &amp;&amp; mysql_secure_installation</li>
<li>yum install -y icinga2-ido-mysql &amp;&amp; icinga2 feature enable ido-mysql</li>
<li>配置文件位于/etc/icinga2/features-available，修改默认密码</li>
</ul>
</li>
<li>安装icinga web2<ul>
<li>cinga2 feature enable command</li>
<li>systemctl restart icinga2.service</li>
<li>sudo usermod -a -G icingacmd apache</li>
<li>id apache</li>
<li>sudo yum install icingaweb2 icingacli -y</li>
<li>sudo icingacli setup config webserver apache –document-root /usr/share/icingaweb2/public</li>
<li>sudo systemctl restart httpd.service</li>
<li>sudo icingacli setup token create</li>
</ul>
</li>
<li>安装高亮插件 install vim highlighting plugin<ul>
<li>yum install vim-icinga2</li>
<li>touch ~/.vimrc</li>
<li>echo “syntax on” &gt;&gt; ~/.vimrc</li>
</ul>
</li>
<li>节点设置，使用<a href="https://docs.icinga.com/icinga2/latest/doc/module/icinga2/chapter/distributed-monitoring?highlight-search=Host%20certificate%20common%20name#distributed-monitoring-security" target="_blank" rel="external">icinga2 node wizard</a><ul>
<li>注意master节点的zone.conf文件，需要修改master zone名称为“master”，不能使用默认的NodeName</li>
<li>注意生成ssl key用于master/client加密通讯</li>
</ul>
</li>
</ul>
<h3 id="client安装"><a href="#client安装" class="headerlink" title="client安装"></a>client安装</h3><ul>
<li>节点设置，使用<a href="https://docs.icinga.com/icinga2/latest/doc/module/icinga2/chapter/distributed-monitoring?highlight-search=Host%20certificate%20common%20name#distributed-monitoring-security" target="_blank" rel="external">icinga2 node wizard</a><ul>
<li>连接的建立方式，一般从master/satelite机器向client机器建立连接，client机器不需要建立向master/satelite机器的连接（不需要知道master/satelite机器连接）</li>
</ul>
</li>
</ul>
<h3 id="服务器上线监控"><a href="#服务器上线监控" class="headerlink" title="服务器上线监控"></a>服务器上线监控</h3><ul>
<li>定时通过网络查看服务器是否在线</li>
<li><img src="https://code.aliyun.com/jindouyuncode/jdy-solution-master/uploads/15119d43ec776b90babfd6ad7532f8c0/image.png" alt="image"></li>
<li>hostalive 默认的服务器监控命令<pre><code><br>object Host “icinga-cache1.jindouyun.com” {<br>check_command = “hostalive”<br>address = “10.28.204.99”<br>vars.client_endpoint = name //follows the convention that host name == endpoint name<br>vars.type = “cache”<br>}<br></code></pre></li>
<li>ssh 通过指定端口连接服务器，确定服务器是否在线<pre><code><br>object Host “icinga-train-pricenode04.jindouyun.com” {<br>check_command = “ssh”<br>vars.client_endpoint = name<br>vars.ssh_address = “221.1.1.1”<br>vars.ssh_port = “12345”<br>vars.type = “node”<br>}<br></code></pre></li>
</ul>
<h3 id="redis监控"><a href="#redis监控" class="headerlink" title="redis监控"></a>redis监控</h3><h3 id="ssdb监控"><a href="#ssdb监控" class="headerlink" title="ssdb监控"></a>ssdb监控</h3><h3 id="外部插件"><a href="#外部插件" class="headerlink" title="外部插件"></a>外部插件</h3><ul>
<li>icinga大量使用perl脚本作为外部插件的实现方式，安装perl<ul>
<li>安装CPAN：yum install perl-CPAN</li>
<li>cpan:&gt; force install Redis</li>
<li>下载插件脚本并赋予执行权限</li>
</ul>
</li>
<li>常用外部插件<ul>
<li>报表：graphite</li>
<li>nagios-plugin自带的check_redis.pl等插件</li>
<li>自己实现短信插件（TODO）</li>
</ul>
</li>
</ul>
<h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><h2 id="load过高问题"><a href="#load过高问题" class="headerlink" title="load过高问题"></a>load过高问题</h2><h2 id="集群搭设"><a href="#集群搭设" class="headerlink" title="集群搭设"></a>集群搭设</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/分布式服务监控 - 概述/" data-id="cjfv497ec0009j4qhz8d72f2v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Continuous-Integration-Based-On-Aliyun-Crp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/24/Continuous-Integration-Based-On-Aliyun-Crp/" class="article-date">
  <time datetime="2016-09-24T09:59:47.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/24/Continuous-Integration-Based-On-Aliyun-Crp/">Continuous Integration Based On Aliyun Crp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>## </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/24/Continuous-Integration-Based-On-Aliyun-Crp/" data-id="cjfv497e00003j4qh9rhipd1v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/运维-DevOps/">运维,DevOps</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Message-Push" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/24/Message-Push/" class="article-date">
  <time datetime="2016-09-24T09:04:56.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/24/Message-Push/">Message Push</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>概述</li>
<li>基本目标&amp;高级目标</li>
<li>实现方式</li>
<li>原理贯通</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>互联网公司都少不了要向用户推送各类信息，比如用户激活、修改密码、各类验证码等功能性信息，营销活动、网站推广等各类运营推广信息，定期的信息推送、用户关怀等各类功能。</li>
<li>当前信息的推送方式一般包括以下几类：向邮箱用户发送邮件、向电信用户发送短信以及向智能终端（智能手机、平板电脑等）用户发送的推送通知。实现这些功能看似都比较简单，一般都是一个简单的接口就可以完成发送，例如发送email，可以通过java的邮件规范实现包，直接设置收发方信息、邮件内容（html、text）等来完成：javax.mail.Transport#send(javax.mail.Message)。但是，在企业级的业务场景中，除了完成接口的调用，还要考虑许多其它的因素。</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>基本目标：完成信息推送</li>
<li>高级目标：保证信息到达率、提升展示效果</li>
</ul>
<h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><ul>
<li>指标：</li>
<li>邮件能否高效送达用户，注意是收件箱，不是垃圾箱，Gmail与QQ的问题尤其头疼<br>　　- 减少退信邮件和垃圾邮件<br>　　- 触达效果要可追踪分析<br>　　- 减少人力成本，按需可控发送成本</li>
<li>垃圾邮件防御机制：<font color="blue">使用dns系统来定位和监管邮件发送者，通过签名机制防止冒充盗用</font></li>
<li>通过在 DNS 中查找目标服务器的地址，发送方服务器可以正确地将邮件路由至收件人。DNS 使用两种记录：Mail Exchanger (MX) 记录和 A 记录。MX 记录将域名称与一个或多个邮件主机名称相对应。A 记录则将主机名与服务器的 IP 地址相对应。</li>
<li>SPF是指Sender Policy Framework，是为了防范垃圾邮件而提出来的一种DNS记录类型，SPF是一种TXT类型的记录。SPF记录的本质，就是向收件人宣告：本域名的邮件从清单上所列IP发出的都是合法邮件，并非冒充的垃圾邮件。</li>
<li><p>DKIM（DomainKeys Identified Mail）是一种电子邮件的验证技术，使用密码学的基础提供了签名与验证的功能。一般来说，发送方会在电子邮件的标头插入DKIM-Signature及电子签名信息。而接收方则通过DNS查询得到公开密钥后进行验证。</p>
</li>
<li><p>到达率保证</p>
</li>
<li>DNS设置</li>
<li>DKIM配置</li>
<li><p>发送情况监控统计</p>
</li>
<li><p>模板准确率</p>
</li>
<li>邮件模板的设计原则是，保证尽可能多的主流邮件客户端正确展示。因为很多邮件客户端（如Outlook和Gmail）都会过滤HTML设置，过滤之后会导致邮件面目全非。具体的设计原则可以参考阮一峰的这篇博客——<a href="http://www.ruanyifeng.com/blog/2013/06/html_email.html" target="_blank" rel="external">html email编写指南</a>。</li>
<li>DocType。由于java mail的标准基本近些年一直处于停滞状态，因此DocType兼容性最好的是XHTML 1.0 strict，使用这个docType意味着不能使用HTML5的语法</li>
<li>Layout。邮件布局必须使用表格，有几行内容就设计几个row来展示</li>
<li>图片。图片是唯一可以引用的外部资源，css文件、字体文件、视频等都无法引用。另外，不少客户端默认都不展示图片，要确保图片不能加载时，主内容也能正确展示。</li>
<li><p>行内样式。由于网页头可能会被客户端删除，因此使用行内样式能最大限度的保障邮件的展示率。</p>
</li>
<li><font color="red">邮件方案</font></li>
<li>互联网公司有很多专业提供邮箱发送解决方案的产品，如SAE、sendcloud、阿里云等。通过这些产品完成一些指定的配置，即可帮用户完成到达率保证的相关配置，快速实现高触达率的邮件服务，价格也比较低。如果企业内没有从事过SMTP服务搭建的人员，建议使用类似的服务来实现邮件发送。</li>
<li>成熟的产品一般也会提供邮件发送情况统计报表，方便监控邮件的发送成功率、退信率、垃圾邮件举报等情况</li>
<li><img src="https://striker.teambition.net/thumbnail/110jf10c37e5656de7f990d87feb33ebae5d/w/800/h/399"></li>
<li><a href="http://www.sendcloud.net/" target="_blank" rel="external">sendcloud</a>，接入方式直接参考各产品的文档，一般都是几个API实现</li>
<li><font color="red">账号：wxd@jindouyun.com，密码：Tjup…</font>，后续还要用企业账号申请，并配置正式的发信域名</li>
</ul>
<h2 id="短信"><a href="#短信" class="headerlink" title="短信"></a>短信</h2><ul>
<li>短信一般都是简单的文本格式+链接，不涉及多媒体数据。一般短信服务商都会要求建立模板并进行审核，以防发送违禁数据或短信轰炸。对类似行为的账号也会采取一定的处罚措施</li>
<li>垃圾短信的过滤策略跟电信运营商有关，一般用户触发的短信数量和内容都不会触发过滤机制。如果是大规模的推送（如营销推广等），需要注意内容和每日/每月发送数量（具体策略需向短信服务商或电信运营商了解）</li>
<li>内容上可以借鉴这篇<a href="http://www.iyunying.org/yxzs/23952.html" target="_blank" rel="external">文章1</a>，<a href="http://toutiao.com/i6208085599543968258/" target="_blank" rel="external">文章2</a>，（<font color="red">未验证</font>）</li>
<li><font color="red">短信方案</font></li>
<li><a href="云片网">http://www.yunpian.com/</a>，参考官方API完成接入，对国内短信、国际短信、语音信息、流量等都有支持</li>
<li>提供发送到达率、失败原因、时间等各类统计</li>
<li>价格大约在5分钱左右（短信）</li>
<li>账号：ops@jindouyun.com</li>
</ul>
<h2 id="app推送"><a href="#app推送" class="headerlink" title="app推送"></a>app推送</h2><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><h3 id="android"><a href="#android" class="headerlink" title="android"></a>android</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/html_email.html" target="_blank" rel="external">html email编写指南</a></li>
<li><a href="http://it.sohu.com/20121212/n360239343.shtml" target="_blank" rel="external">搜狐SendCloud 适用于开发者的邮件发送平台</a></li>
<li><a href="http://blog.csdn.net/mal327/article/details/6700493" target="_blank" rel="external">邮件服务器DNS设置—–MX、SPF、DKIM记录详解</a></li>
<li><a href="https://zh.wikipedia.org/wiki/DKIM" target="_blank" rel="external">DKIM-WIKI</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">SMTP-WIKI</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/24/Message-Push/" data-id="cjfv497df0000j4qh0xl2to4g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/用户触达/">用户触达</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/24/hello-world/" class="article-date">
  <time datetime="2016-09-24T06:48:58.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/24/hello-world/" data-id="cjfv497du0001j4qhcnlo1f28" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell-linux-ops/">shell,linux,ops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/用户触达/">用户触达</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维-DevOps/">运维,DevOps</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/shell-linux-ops/" style="font-size: 10px;">shell,linux,ops</a> <a href="/tags/用户触达/" style="font-size: 10px;">用户触达</a> <a href="/tags/运维-DevOps/" style="font-size: 10px;">运维,DevOps</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/10/java团队code style规范/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/26/旅行行业基础数据本地管理/">旅行行业基础数据本地管理</a>
          </li>
        
          <li>
            <a href="/2018/03/21/shell-commands-case-study/">shell commands case study</a>
          </li>
        
          <li>
            <a href="/2017/07/15/servermonitoring/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/04/27/操作系统/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 SeventyNine<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>